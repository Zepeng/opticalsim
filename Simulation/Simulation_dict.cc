// Generated at Thu Aug  8 11:06:22 2013. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/nusoft/app/externals/gccxml/v0_9_20120702/Linux64bit+2.6-2.5-gcc47/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="${GCC_FQ_DIR}/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/nusoft/app/externals/gccxml/v0_9_20120702/Linux64bit+2.6-2.5-gcc47/bin/gccxml_cc1plus"
  GCCXML_CPP="/nusoft/app/externals/gccxml/v0_9_20120702/Linux64bit+2.6-2.5-gcc47/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/nusoft/app/externals/gccxml/v0_9_20120702/Linux64bit+2.6-2.5-gcc47/share/gccxml-0.9/GCC/4.7" -isystem"/nusoft/app/externals/gcc/v4_7_1/Linux64bit+2.6-2.5/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../include/c++/4.7.1" -isystem"/nusoft/app/externals/gcc/v4_7_1/Linux64bit+2.6-2.5/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../include/c++/4.7.1/x86_64-unknown-linux-gnu" -isystem"/nusoft/app/externals/gcc/v4_7_1/Linux64bit+2.6-2.5/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.1/../../../../include/c++/4.7.1/backward" -isystem"/nusoft/app/externals/gcc/v4_7_1/Linux64bit+2.6-2.5/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.1/include" -isystem"/nusoft/app/externals/gcc/v4_7_1/Linux64bit+2.6-2.5/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.1/include-fixed" -isystem"/usr/local/include" -isystem"/nusoft/app/externals/gcc/v4_7_1/Linux64bit+2.6-2.5/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/nusoft/app/externals/gccxml/v0_9_20120702/Linux64bit+2.6-2.5-gcc47/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.1
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"

#include <SimChannel.h>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("sim") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("art") );
  ::Reflex::Type type_114 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_155 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_576 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_504 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_87 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_29 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_185 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1614 = ::Reflex::TypeBuilder(Reflex::Literal("TVector3"));
  ::Reflex::Type type_3551 = ::Reflex::TypeBuilder(Reflex::Literal("sim::IDE"));
  ::Reflex::Type type_16 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_167 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_319 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_3549 = ::Reflex::TypeBuilder(Reflex::Literal("sim::OnePhoton"));
  ::Reflex::Type type_5347 = ::Reflex::TypeBuilder(Reflex::Literal("art::EDProduct"));
  ::Reflex::Type type_3548 = ::Reflex::TypeBuilder(Reflex::Literal("sim::SimPhotons"));
  ::Reflex::Type type_3554 = ::Reflex::TypeBuilder(Reflex::Literal("sim::SimChannel"));
  ::Reflex::Type type_2269 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_3553 = ::Reflex::TypeBuilder(Reflex::Literal("sim::BeamGateInfo"));
  ::Reflex::Type type_2782 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_2695 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<int>"));
  ::Reflex::Type type_3552 = ::Reflex::TypeBuilder(Reflex::Literal("sim::LBNE10ktPhotons"));
  ::Reflex::Type type_2274 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::IDE>"));
  ::Reflex::Type type_2700 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<sim::IDE>"));
  ::Reflex::Type type_2573 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned short>"));
  ::Reflex::Type type_2271 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::OnePhoton>"));
  ::Reflex::Type type_2272 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::SimPhotons>"));
  ::Reflex::Type type_2273 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::SimChannel>"));
  ::Reflex::Type type_2266 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::BeamGateInfo>"));
  ::Reflex::Type type_2697 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<sim::OnePhoton>"));
  ::Reflex::Type type_2698 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<sim::SimPhotons>"));
  ::Reflex::Type type_2699 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<sim::SimChannel>"));
  ::Reflex::Type type_5312 = ::Reflex::TypeBuilder(Reflex::Literal("art::Wrapper<std::vector<int> >"));
  ::Reflex::Type type_2692 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<sim::BeamGateInfo>"));
  ::Reflex::Type type_2270 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::LBNE10ktPhotons>"));
  ::Reflex::Type type_2696 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<sim::LBNE10ktPhotons>"));
  ::Reflex::Type type_2225 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >"));
  ::Reflex::Type type_5315 = ::Reflex::TypeBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::SimPhotons> >"));
  ::Reflex::Type type_5316 = ::Reflex::TypeBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::SimChannel> >"));
  ::Reflex::Type type_5311 = ::Reflex::TypeBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::BeamGateInfo> >"));
  ::Reflex::Type type_4518 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<int> >"));
  ::Reflex::Type type_2783 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >"));
  ::Reflex::Type type_2625 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned short,std::vector<sim::IDE> >"));
  ::Reflex::Type type_5313 = ::Reflex::TypeBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::LBNE10ktPhotons> >"));
  ::Reflex::Type type_4467 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<int*,std::vector<int> >"));
  ::Reflex::Type type_4522 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<sim::IDE> >"));
  ::Reflex::Type type_2229 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::IDE,std::allocator<sim::IDE> >"));
  ::Reflex::Type type_2635 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned short,std::vector<sim::IDE> >"));
  ::Reflex::Type type_4468 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const int*,std::vector<int> >"));
  ::Reflex::Type type_4523 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<sim::OnePhoton> >"));
  ::Reflex::Type type_4520 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<sim::SimPhotons> >"));
  ::Reflex::Type type_4521 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<sim::SimChannel> >"));
  ::Reflex::Type type_4517 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<sim::BeamGateInfo> >"));
  ::Reflex::Type type_4475 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >"));
  ::Reflex::Type type_4519 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<sim::LBNE10ktPhotons> >"));
  ::Reflex::Type type_2230 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> >"));
  ::Reflex::Type type_2227 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::SimPhotons,std::allocator<sim::SimPhotons> >"));
  ::Reflex::Type type_2228 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::SimChannel,std::allocator<sim::SimChannel> >"));
  ::Reflex::Type type_4476 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const sim::IDE*,std::vector<sim::IDE> >"));
  ::Reflex::Type type_2224 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> >"));
  ::Reflex::Type type_2706 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned short,std::vector<sim::IDE> > >"));
  ::Reflex::Type type_4477 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >"));
  ::Reflex::Type type_2793 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<int*,std::vector<int> > >"));
  ::Reflex::Type type_4471 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >"));
  ::Reflex::Type type_4473 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >"));
  ::Reflex::Type type_2226 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> >"));
  ::Reflex::Type type_2341 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >"));
  ::Reflex::Type type_4465 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >"));
  ::Reflex::Type type_4478 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const sim::OnePhoton*,std::vector<sim::OnePhoton> >"));
  ::Reflex::Type type_2792 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const int*,std::vector<int> > >"));
  ::Reflex::Type type_4472 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const sim::SimPhotons*,std::vector<sim::SimPhotons> >"));
  ::Reflex::Type type_4474 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const sim::SimChannel*,std::vector<sim::SimChannel> >"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >"));
  ::Reflex::Type type_4466 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >"));
  ::Reflex::Type type_4469 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >"));
  ::Reflex::Type type_2801 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> > >"));
  ::Reflex::Type type_4470 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >"));
  ::Reflex::Type type_2800 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const sim::IDE*,std::vector<sim::IDE> > >"));
  ::Reflex::Type type_2637 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >,bool>"));
  ::Reflex::Type type_2805 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> > >"));
  ::Reflex::Type type_2797 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> > >"));
  ::Reflex::Type type_2799 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> > >"));
  ::Reflex::Type type_2809 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > > >"));
  ::Reflex::Type type_2791 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> > >"));
  ::Reflex::Type type_2804 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const sim::OnePhoton*,std::vector<sim::OnePhoton> > >"));
  ::Reflex::Type type_2796 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const sim::SimPhotons*,std::vector<sim::SimPhotons> > >"));
  ::Reflex::Type type_2798 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const sim::SimChannel*,std::vector<sim::SimChannel> > >"));
  ::Reflex::Type type_2808 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > > >"));
  ::Reflex::Type type_2790 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> > >"));
  ::Reflex::Type type_2795 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> > >"));
  ::Reflex::Type type_2794 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> > >"));
  ::Reflex::Type type_2636 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >,std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > > >"));
  ::Reflex::Type type_2634 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > > >"));
  ::Reflex::Type type_2530 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned short,std::pair<const unsigned short,std::vector<sim::IDE> >,std::_Select1st<std::pair<const unsigned short,std::vector<sim::IDE> > >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,std::vector<sim::IDE> > > >"));
  ::Reflex::Type type_6421 = ::Reflex::ReferenceBuilder(type_3553);
  ::Reflex::Type type_3553c = ::Reflex::ConstBuilder(type_3553);
  ::Reflex::Type type_6423 = ::Reflex::ReferenceBuilder(type_3553c);
  ::Reflex::Type type_6105 = ::Reflex::PointerBuilder(type_3553);
  ::Reflex::Type type_6419 = ::Reflex::PointerBuilder(type_3553c);
  ::Reflex::Type type_2662 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_16);
  ::Reflex::Type type_2459 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_155);
  ::Reflex::Type type_2692c = ::Reflex::ConstBuilder(type_2692);
  ::Reflex::Type type_13354 = ::Reflex::ReferenceBuilder(type_2692c);
  ::Reflex::Type type_2266c = ::Reflex::ConstBuilder(type_2266);
  ::Reflex::Type type_13523 = ::Reflex::ReferenceBuilder(type_2266c);
  ::Reflex::Type type_13524 = ::Reflex::ReferenceBuilder(type_2266);
  ::Reflex::Type type_2979 = ::Reflex::PointerBuilder(type_114);
  ::Reflex::Type type_114c = ::Reflex::ConstBuilder(type_114);
  ::Reflex::Type type_6484 = ::Reflex::PointerBuilder(type_114c);
  ::Reflex::Type type_6486 = ::Reflex::ReferenceBuilder(type_114);
  ::Reflex::Type type_6488 = ::Reflex::ReferenceBuilder(type_114c);
  ::Reflex::Type type_2695c = ::Reflex::ConstBuilder(type_2695);
  ::Reflex::Type type_13367 = ::Reflex::ReferenceBuilder(type_2695c);
  ::Reflex::Type type_2269c = ::Reflex::ConstBuilder(type_2269);
  ::Reflex::Type type_13525 = ::Reflex::ReferenceBuilder(type_2269c);
  ::Reflex::Type type_13526 = ::Reflex::ReferenceBuilder(type_2269);
  ::Reflex::Type type_6551 = ::Reflex::ReferenceBuilder(type_3552);
  ::Reflex::Type type_3552c = ::Reflex::ConstBuilder(type_3552);
  ::Reflex::Type type_6553 = ::Reflex::ReferenceBuilder(type_3552c);
  ::Reflex::Type type_6142 = ::Reflex::PointerBuilder(type_3552);
  ::Reflex::Type type_6549 = ::Reflex::PointerBuilder(type_3552c);
  ::Reflex::Type type_2696c = ::Reflex::ConstBuilder(type_2696);
  ::Reflex::Type type_13380 = ::Reflex::ReferenceBuilder(type_2696c);
  ::Reflex::Type type_2270c = ::Reflex::ConstBuilder(type_2270);
  ::Reflex::Type type_13528 = ::Reflex::ReferenceBuilder(type_2270c);
  ::Reflex::Type type_13529 = ::Reflex::ReferenceBuilder(type_2270);
  ::Reflex::Type type_6616 = ::Reflex::ReferenceBuilder(type_3549);
  ::Reflex::Type type_3549c = ::Reflex::ConstBuilder(type_3549);
  ::Reflex::Type type_6618 = ::Reflex::ReferenceBuilder(type_3549c);
  ::Reflex::Type type_6218 = ::Reflex::PointerBuilder(type_3549);
  ::Reflex::Type type_6614 = ::Reflex::PointerBuilder(type_3549c);
  ::Reflex::Type type_2697c = ::Reflex::ConstBuilder(type_2697);
  ::Reflex::Type type_13432 = ::Reflex::ReferenceBuilder(type_2697c);
  ::Reflex::Type type_2271c = ::Reflex::ConstBuilder(type_2271);
  ::Reflex::Type type_13531 = ::Reflex::ReferenceBuilder(type_2271c);
  ::Reflex::Type type_13532 = ::Reflex::ReferenceBuilder(type_2271);
  ::Reflex::Type type_6681 = ::Reflex::ReferenceBuilder(type_3548);
  ::Reflex::Type type_3548c = ::Reflex::ConstBuilder(type_3548);
  ::Reflex::Type type_6683 = ::Reflex::ReferenceBuilder(type_3548c);
  ::Reflex::Type type_6161 = ::Reflex::PointerBuilder(type_3548);
  ::Reflex::Type type_6679 = ::Reflex::PointerBuilder(type_3548c);
  ::Reflex::Type type_2698c = ::Reflex::ConstBuilder(type_2698);
  ::Reflex::Type type_13393 = ::Reflex::ReferenceBuilder(type_2698c);
  ::Reflex::Type type_2272c = ::Reflex::ConstBuilder(type_2272);
  ::Reflex::Type type_13534 = ::Reflex::ReferenceBuilder(type_2272c);
  ::Reflex::Type type_13535 = ::Reflex::ReferenceBuilder(type_2272);
  ::Reflex::Type type_443 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_167);
  ::Reflex::Type type_6746 = ::Reflex::ReferenceBuilder(type_3554);
  ::Reflex::Type type_3554c = ::Reflex::ConstBuilder(type_3554);
  ::Reflex::Type type_6748 = ::Reflex::ReferenceBuilder(type_3554c);
  ::Reflex::Type type_6180 = ::Reflex::PointerBuilder(type_3554);
  ::Reflex::Type type_6744 = ::Reflex::PointerBuilder(type_3554c);
  ::Reflex::Type type_2699c = ::Reflex::ConstBuilder(type_2699);
  ::Reflex::Type type_13406 = ::Reflex::ReferenceBuilder(type_2699c);
  ::Reflex::Type type_2273c = ::Reflex::ConstBuilder(type_2273);
  ::Reflex::Type type_13537 = ::Reflex::ReferenceBuilder(type_2273c);
  ::Reflex::Type type_13538 = ::Reflex::ReferenceBuilder(type_2273);
  ::Reflex::Type type_6811 = ::Reflex::ReferenceBuilder(type_3551);
  ::Reflex::Type type_3551c = ::Reflex::ConstBuilder(type_3551);
  ::Reflex::Type type_6813 = ::Reflex::ReferenceBuilder(type_3551c);
  ::Reflex::Type type_6199 = ::Reflex::PointerBuilder(type_3551);
  ::Reflex::Type type_6809 = ::Reflex::PointerBuilder(type_3551c);
  ::Reflex::Type type_2700c = ::Reflex::ConstBuilder(type_2700);
  ::Reflex::Type type_13419 = ::Reflex::ReferenceBuilder(type_2700c);
  ::Reflex::Type type_2274c = ::Reflex::ConstBuilder(type_2274);
  ::Reflex::Type type_13540 = ::Reflex::ReferenceBuilder(type_2274c);
  ::Reflex::Type type_13541 = ::Reflex::ReferenceBuilder(type_2274);
  ::Reflex::Type type_14046 = ::Reflex::ReferenceBuilder(type_2625);
  ::Reflex::Type type_2625c = ::Reflex::ConstBuilder(type_2625);
  ::Reflex::Type type_14047 = ::Reflex::ReferenceBuilder(type_2625c);
  ::Reflex::Type type_319c = ::Reflex::ConstBuilder(type_319);
  ::Reflex::Type type_13954 = ::Reflex::ReferenceBuilder(type_319c);
  ::Reflex::Type type_8635 = ::Reflex::PointerBuilder(type_2635);
  ::Reflex::Type type_2635c = ::Reflex::ConstBuilder(type_2635);
  ::Reflex::Type type_8637 = ::Reflex::PointerBuilder(type_2635c);
  ::Reflex::Type type_8639 = ::Reflex::ReferenceBuilder(type_2635);
  ::Reflex::Type type_8641 = ::Reflex::ReferenceBuilder(type_2635c);
  ::Reflex::Type type_2573c = ::Reflex::ConstBuilder(type_2573);
  ::Reflex::Type type_13955 = ::Reflex::ReferenceBuilder(type_2573c);
  ::Reflex::Type type_2706c = ::Reflex::ConstBuilder(type_2706);
  ::Reflex::Type type_13956 = ::Reflex::ReferenceBuilder(type_2706c);
  ::Reflex::Type type_2783c = ::Reflex::ConstBuilder(type_2783);
  ::Reflex::Type type_14186 = ::Reflex::ReferenceBuilder(type_2783c);
  ::Reflex::Type type_14187 = ::Reflex::ReferenceBuilder(type_2783);
  ::Reflex::Type type_14664 = ::Reflex::ReferenceBuilder(type_5311);
  ::Reflex::Type type_5311c = ::Reflex::ConstBuilder(type_5311);
  ::Reflex::Type type_14665 = ::Reflex::ReferenceBuilder(type_5311c);
  ::Reflex::Type type_14669 = ::Reflex::ReferenceBuilder(type_5312);
  ::Reflex::Type type_5312c = ::Reflex::ConstBuilder(type_5312);
  ::Reflex::Type type_14670 = ::Reflex::ReferenceBuilder(type_5312c);
  ::Reflex::Type type_14671 = ::Reflex::ReferenceBuilder(type_5313);
  ::Reflex::Type type_5313c = ::Reflex::ConstBuilder(type_5313);
  ::Reflex::Type type_14672 = ::Reflex::ReferenceBuilder(type_5313c);
  ::Reflex::Type type_14675 = ::Reflex::ReferenceBuilder(type_5315);
  ::Reflex::Type type_5315c = ::Reflex::ConstBuilder(type_5315);
  ::Reflex::Type type_14676 = ::Reflex::ReferenceBuilder(type_5315c);
  ::Reflex::Type type_14677 = ::Reflex::ReferenceBuilder(type_5316);
  ::Reflex::Type type_5316c = ::Reflex::ConstBuilder(type_5316);
  ::Reflex::Type type_14678 = ::Reflex::ReferenceBuilder(type_5316c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __sim__BeamGateInfo
#undef __sim__BeamGateInfo
#endif
class __sim__BeamGateInfo {
  public:
  __sim__BeamGateInfo();
  double fm_start;
  double fm_width;
};
#ifdef __std__vector_sim__BeamGateInfo_
#undef __std__vector_sim__BeamGateInfo_
#endif
class __std__vector_sim__BeamGateInfo_ : protected ::std::_Vector_base<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > {
  public:
  __std__vector_sim__BeamGateInfo_();
};
#ifdef __std__vector_int_
#undef __std__vector_int_
#endif
class __std__vector_int_ : protected ::std::_Vector_base<int,std::allocator<int> > {
  public:
  __std__vector_int_();
};
#ifdef __sim__LBNE10ktPhotons
#undef __sim__LBNE10ktPhotons
#endif
class __sim__LBNE10ktPhotons {
  public:
  __sim__LBNE10ktPhotons();
  int OpChannel;
  ::std::map<int,int> DetectedPhotons;
};
#ifdef __std__vector_sim__LBNE10ktPhotons_
#undef __std__vector_sim__LBNE10ktPhotons_
#endif
class __std__vector_sim__LBNE10ktPhotons_ : protected ::std::_Vector_base<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > {
  public:
  __std__vector_sim__LBNE10ktPhotons_();
};
#ifdef __sim__OnePhoton
#undef __sim__OnePhoton
#endif
class __sim__OnePhoton {
  public:
  __sim__OnePhoton();
  bool SetInSD;
  ::TVector3 InitialPosition;
  float Time;
  float Energy;
};
#ifdef __std__vector_sim__OnePhoton_
#undef __std__vector_sim__OnePhoton_
#endif
class __std__vector_sim__OnePhoton_ : protected ::std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> > {
  public:
  __std__vector_sim__OnePhoton_();
};
#ifdef __sim__SimPhotons
#undef __sim__SimPhotons
#endif
class __sim__SimPhotons : public ::std::vector<sim::OnePhoton> {
  public:
  __sim__SimPhotons();
  int fOpChannel;
};
#ifdef __std__vector_sim__SimPhotons_
#undef __std__vector_sim__SimPhotons_
#endif
class __std__vector_sim__SimPhotons_ : protected ::std::_Vector_base<sim::SimPhotons,std::allocator<sim::SimPhotons> > {
  public:
  __std__vector_sim__SimPhotons_();
};
#ifdef __sim__SimChannel
#undef __sim__SimChannel
#endif
class __sim__SimChannel {
  public:
  __sim__SimChannel();
  ::uint32_t fChannel;
  ::std::map<unsigned short,std::vector<sim::IDE> > fTDCIDEs;
};
#ifdef __std__vector_sim__SimChannel_
#undef __std__vector_sim__SimChannel_
#endif
class __std__vector_sim__SimChannel_ : protected ::std::_Vector_base<sim::SimChannel,std::allocator<sim::SimChannel> > {
  public:
  __std__vector_sim__SimChannel_();
};
#ifdef __sim__IDE
#undef __sim__IDE
#endif
class __sim__IDE {
  public:
  __sim__IDE();
  int trackID;
  double numElectrons;
  double energy;
  double x;
  double y;
  double z;
};
#ifdef __std__vector_sim__IDE_
#undef __std__vector_sim__IDE_
#endif
class __std__vector_sim__IDE_ : protected ::std::_Vector_base<sim::IDE,std::allocator<sim::IDE> > {
  public:
  __std__vector_sim__IDE_();
};
#ifdef __std__pair_unsignedsshort_std__vector_sim__IDE_s_
#undef __std__pair_unsignedsshort_std__vector_sim__IDE_s_
#endif
struct __std__pair_unsignedsshort_std__vector_sim__IDE_s_ {
  public:
  __std__pair_unsignedsshort_std__vector_sim__IDE_s_();
  unsigned short first;
  ::std::vector<sim::IDE> second;
};
#ifdef __std__map_unsignedsshort_std__vector_sim__IDE_s_
#undef __std__map_unsignedsshort_std__vector_sim__IDE_s_
#endif
class __std__map_unsignedsshort_std__vector_sim__IDE_s_ {
  public:
  __std__map_unsignedsshort_std__vector_sim__IDE_s_();
  ::std::_Rb_tree<unsigned short,std::pair<const unsigned short,std::vector<sim::IDE> >,std::_Select1st<std::pair<const unsigned short,std::vector<sim::IDE> > >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,std::vector<sim::IDE> > > > _M_t;
};
#ifdef __art__Wrapper_std__vector_sim__BeamGateInfo_s_
#undef __art__Wrapper_std__vector_sim__BeamGateInfo_s_
#endif
class __art__Wrapper_std__vector_sim__BeamGateInfo_s_ : public ::art::EDProduct {
  public:
  __art__Wrapper_std__vector_sim__BeamGateInfo_s_();
  virtual ~__art__Wrapper_std__vector_sim__BeamGateInfo_s_() throw();
  bool present;
  ::std::vector<sim::BeamGateInfo> obj;
};
#ifdef __art__Wrapper_std__vector_int_s_
#undef __art__Wrapper_std__vector_int_s_
#endif
class __art__Wrapper_std__vector_int_s_ : public ::art::EDProduct {
  public:
  __art__Wrapper_std__vector_int_s_();
  virtual ~__art__Wrapper_std__vector_int_s_() throw();
  bool present;
  ::std::vector<int> obj;
};
#ifdef __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_
#undef __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_
#endif
class __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_ : public ::art::EDProduct {
  public:
  __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_();
  virtual ~__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_() throw();
  bool present;
  ::std::vector<sim::LBNE10ktPhotons> obj;
};
#ifdef __art__Wrapper_std__vector_sim__SimPhotons_s_
#undef __art__Wrapper_std__vector_sim__SimPhotons_s_
#endif
class __art__Wrapper_std__vector_sim__SimPhotons_s_ : public ::art::EDProduct {
  public:
  __art__Wrapper_std__vector_sim__SimPhotons_s_();
  virtual ~__art__Wrapper_std__vector_sim__SimPhotons_s_() throw();
  bool present;
  ::std::vector<sim::SimPhotons> obj;
};
#ifdef __art__Wrapper_std__vector_sim__SimChannel_s_
#undef __art__Wrapper_std__vector_sim__SimChannel_s_
#endif
class __art__Wrapper_std__vector_sim__SimChannel_s_ : public ::art::EDProduct {
  public:
  __art__Wrapper_std__vector_sim__SimChannel_s_();
  virtual ~__art__Wrapper_std__vector_sim__SimChannel_s_() throw();
  bool present;
  ::std::vector<sim::SimChannel> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class BeamGateInfo -------------------------------
static  void operator_11261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::sim::BeamGateInfo*)o)->operator=)(*(const ::sim::BeamGateInfo*)arg[0]);
  else   (((::sim::BeamGateInfo*)o)->operator=)(*(const ::sim::BeamGateInfo*)arg[0]);
}

static void constructor_11262( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::BeamGateInfo(*(const ::sim::BeamGateInfo*)arg[0]);
  else ::new(mem) ::sim::BeamGateInfo(*(const ::sim::BeamGateInfo*)arg[0]);
}

static void constructor_11263( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::sim::BeamGateInfo();
  else ::new(mem) ::sim::BeamGateInfo();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::sim::BeamGateInfo(*(double*)arg[0]);
  else ::new(mem) ::sim::BeamGateInfo(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::sim::BeamGateInfo(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::sim::BeamGateInfo(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static void destructor_11264(void*, void * o, const std::vector<void*>&, void *) {
(((::sim::BeamGateInfo*)o)->::sim::BeamGateInfo::~BeamGateInfo)();
}
static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::BeamGateInfo();
  else ::new(mem) ::sim::BeamGateInfo();
}

static void method_newdel_3553( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::sim::BeamGateInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::sim::BeamGateInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::sim::BeamGateInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::sim::BeamGateInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::sim::BeamGateInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BeamGateInfo -------------------------------
void __sim__BeamGateInfo_db_datamem(Reflex::Class*);
void __sim__BeamGateInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __sim__BeamGateInfo_datamem_bld(&__sim__BeamGateInfo_db_datamem);
Reflex::GenreflexMemberBuilder __sim__BeamGateInfo_funcmem_bld(&__sim__BeamGateInfo_db_funcmem);
void __sim__BeamGateInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("sim::BeamGateInfo"), typeid(::sim::BeamGateInfo), sizeof(::sim::BeamGateInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6421, type_6423), Reflex::Literal("operator="), operator_11261, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6423), Reflex::Literal("BeamGateInfo"), constructor_11262, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_185, type_185), Reflex::Literal("BeamGateInfo"), constructor_11263, 0, "start=0;width=1.6e+3", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BeamGateInfo"), destructor_11264, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BeamGateInfo"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3553, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__sim__BeamGateInfo_datamem_bld);
}

//------Delayed data member builder for class BeamGateInfo -------------------
void __sim__BeamGateInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_185, Reflex::Literal("fm_start"), OffsetOf(__shadow__::__sim__BeamGateInfo, fm_start), ::Reflex::PRIVATE)
  .AddDataMember(type_185, Reflex::Literal("fm_width"), OffsetOf(__shadow__::__sim__BeamGateInfo, fm_width), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class BeamGateInfo -------------------
void __sim__BeamGateInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > -------------------------------
static void constructor_6432( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::BeamGateInfo>();
  else ::new(mem) ::std::vector<sim::BeamGateInfo>();
}

static void constructor_6433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::BeamGateInfo>(*(const ::std::allocator<sim::BeamGateInfo>*)arg[0]);
  else ::new(mem) ::std::vector<sim::BeamGateInfo>(*(const ::std::allocator<sim::BeamGateInfo>*)arg[0]);
}

static void constructor_6434( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::BeamGateInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<sim::BeamGateInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::BeamGateInfo>(*(::std::size_t*)arg[0],
      *(const ::sim::BeamGateInfo*)arg[1]);
  else ::new(mem) ::std::vector<sim::BeamGateInfo>(*(::std::size_t*)arg[0],
      *(const ::sim::BeamGateInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::BeamGateInfo>(*(::std::size_t*)arg[0],
      *(const ::sim::BeamGateInfo*)arg[1],
      *(const ::std::allocator<sim::BeamGateInfo>*)arg[2]);
  else ::new(mem) ::std::vector<sim::BeamGateInfo>(*(::std::size_t*)arg[0],
      *(const ::sim::BeamGateInfo*)arg[1],
      *(const ::std::allocator<sim::BeamGateInfo>*)arg[2]);
  }
}

static void constructor_6435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::BeamGateInfo>(*(const ::std::vector<sim::BeamGateInfo>*)arg[0]);
  else ::new(mem) ::std::vector<sim::BeamGateInfo>(*(const ::std::vector<sim::BeamGateInfo>*)arg[0]);
}

static void destructor_6436(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<sim::BeamGateInfo>*)o)->::std::vector<sim::BeamGateInfo>::~vector)();
}
static  void operator_6437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::BeamGateInfo>*)o)->operator=)(*(const ::std::vector<sim::BeamGateInfo>*)arg[0]);
  else   (((::std::vector<sim::BeamGateInfo>*)o)->operator=)(*(const ::std::vector<sim::BeamGateInfo>*)arg[0]);
}

static  void method_6438( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::sim::BeamGateInfo*)arg[1]);
}

static  void method_6439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((::std::vector<sim::BeamGateInfo>*)o)->begin)());
  else   (((::std::vector<sim::BeamGateInfo>*)o)->begin)();
}

static  void method_6440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((const ::std::vector<sim::BeamGateInfo>*)o)->begin)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->begin)();
}

static  void method_6441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((::std::vector<sim::BeamGateInfo>*)o)->end)());
  else   (((::std::vector<sim::BeamGateInfo>*)o)->end)();
}

static  void method_6442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((const ::std::vector<sim::BeamGateInfo>*)o)->end)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->end)();
}

static  void method_6447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::BeamGateInfo>*)o)->size)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->size)();
}

static  void method_6448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::BeamGateInfo>*)o)->max_size)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->max_size)();
}

static  void method_6449( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<sim::BeamGateInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<sim::BeamGateInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::sim::BeamGateInfo*)arg[1]);
  }
}

static  void method_6450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::BeamGateInfo>*)o)->capacity)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->capacity)();
}

static  void method_6451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<sim::BeamGateInfo>*)o)->empty)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->empty)();
}

static  void method_6452( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::BeamGateInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::BeamGateInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::BeamGateInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::BeamGateInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::BeamGateInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::BeamGateInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::BeamGateInfo>*)o)->front)();
  else   (((::std::vector<sim::BeamGateInfo>*)o)->front)();
}

static  void method_6459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::BeamGateInfo>*)o)->front)();
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->front)();
}

static  void method_6460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::BeamGateInfo>*)o)->back)();
  else   (((::std::vector<sim::BeamGateInfo>*)o)->back)();
}

static  void method_6461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::BeamGateInfo>*)o)->back)();
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->back)();
}

static  void method_6462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<sim::BeamGateInfo>*)o)->data)());
  else   (((::std::vector<sim::BeamGateInfo>*)o)->data)();
}

static  void method_6463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<sim::BeamGateInfo>*)o)->data)());
  else   (((const ::std::vector<sim::BeamGateInfo>*)o)->data)();
}

static  void method_6464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->push_back)(*(const ::sim::BeamGateInfo*)arg[0]);
}

static  void method_6465( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->pop_back)();
}

static  void method_6466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((::std::vector<sim::BeamGateInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0],
    *(const ::sim::BeamGateInfo*)arg[1]));
  else   (((::std::vector<sim::BeamGateInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0],
    *(const ::sim::BeamGateInfo*)arg[1]);
}

static  void method_6467( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::sim::BeamGateInfo*)arg[2]);
}

static  void method_6468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((::std::vector<sim::BeamGateInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0]));
  else   (((::std::vector<sim::BeamGateInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0]);
}

static  void method_6469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >)((((::std::vector<sim::BeamGateInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[1]));
  else   (((::std::vector<sim::BeamGateInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::BeamGateInfo*,std::vector<sim::BeamGateInfo> >*)arg[1]);
}

static  void method_6470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->swap)(*(::std::vector<sim::BeamGateInfo>*)arg[0]);
}

static  void method_6471( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::BeamGateInfo>*)o)->clear)();
}

static void method_newdel_2266( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<sim::BeamGateInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<sim::BeamGateInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<sim::BeamGateInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<sim::BeamGateInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<sim::BeamGateInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> >")), ::Reflex::BaseOffset< ::std::vector<sim::BeamGateInfo>,::std::_Vector_base<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<sim::BeamGateInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<sim::BeamGateInfo> >::Generate();
}

//------Dictionary for class vector<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > -------------------------------
void __std__vector_sim__BeamGateInfo__db_datamem(Reflex::Class*);
void __std__vector_sim__BeamGateInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_sim__BeamGateInfo__datamem_bld(&__std__vector_sim__BeamGateInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_sim__BeamGateInfo__funcmem_bld(&__std__vector_sim__BeamGateInfo__db_funcmem);
void __std__vector_sim__BeamGateInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<sim::BeamGateInfo>"), typeid(::std::vector<sim::BeamGateInfo>), sizeof(::std::vector<sim::BeamGateInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2224, ::Reflex::BaseOffset< ::std::vector<sim::BeamGateInfo>, ::std::_Vector_base<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3553, Reflex::Literal("std::vector<sim::BeamGateInfo>::_Alloc_value_type"))
  .AddTypedef(type_2224, Reflex::Literal("std::vector<sim::BeamGateInfo>::_Base"))
  .AddTypedef(type_2692, Reflex::Literal("std::vector<sim::BeamGateInfo>::_Tp_alloc_type"))
  .AddTypedef(type_4517, Reflex::Literal("std::vector<sim::BeamGateInfo>::_Alloc_traits"))
  .AddTypedef(type_3553, Reflex::Literal("std::vector<sim::BeamGateInfo>::value_type"))
  .AddTypedef(type_6105, Reflex::Literal("std::vector<sim::BeamGateInfo>::pointer"))
  .AddTypedef(type_6419, Reflex::Literal("std::vector<sim::BeamGateInfo>::const_pointer"))
  .AddTypedef(type_6421, Reflex::Literal("std::vector<sim::BeamGateInfo>::reference"))
  .AddTypedef(type_6423, Reflex::Literal("std::vector<sim::BeamGateInfo>::const_reference"))
  .AddTypedef(type_4465, Reflex::Literal("std::vector<sim::BeamGateInfo>::iterator"))
  .AddTypedef(type_4466, Reflex::Literal("std::vector<sim::BeamGateInfo>::const_iterator"))
  .AddTypedef(type_2790, Reflex::Literal("std::vector<sim::BeamGateInfo>::const_reverse_iterator"))
  .AddTypedef(type_2791, Reflex::Literal("std::vector<sim::BeamGateInfo>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<sim::BeamGateInfo>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<sim::BeamGateInfo>::difference_type"))
  .AddTypedef(type_2692, Reflex::Literal("std::vector<sim::BeamGateInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6432, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13354), Reflex::Literal("vector"), constructor_6433, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6423, type_13354), Reflex::Literal("vector"), constructor_6434, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13523), Reflex::Literal("vector"), constructor_6435, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6436, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2266, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_sim__BeamGateInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > -------------------
void __std__vector_sim__BeamGateInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<sim::BeamGateInfo,std::allocator<sim::BeamGateInfo> > -------------------
void __std__vector_sim__BeamGateInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13524, type_13523), Reflex::Literal("operator="), operator_6437, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6423), Reflex::Literal("assign"), method_6438, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4465), Reflex::Literal("begin"), method_6439, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4466), Reflex::Literal("begin"), method_6440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4465), Reflex::Literal("end"), method_6441, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4466), Reflex::Literal("end"), method_6442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_3553), Reflex::Literal("resize"), method_6449, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6452, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6421, type_2662), Reflex::Literal("operator[]"), operator_6453, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6423, type_2662), Reflex::Literal("operator[]"), operator_6454, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6421, type_2662), Reflex::Literal("at"), method_6456, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6423, type_2662), Reflex::Literal("at"), method_6457, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6421), Reflex::Literal("front"), method_6458, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6423), Reflex::Literal("front"), method_6459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6421), Reflex::Literal("back"), method_6460, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6423), Reflex::Literal("back"), method_6461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6105), Reflex::Literal("data"), method_6462, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6419), Reflex::Literal("data"), method_6463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6423), Reflex::Literal("push_back"), method_6464, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6465, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4465, type_4465, type_6423), Reflex::Literal("insert"), method_6466, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4465, type_2662, type_6423), Reflex::Literal("insert"), method_6467, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4465, type_4465), Reflex::Literal("erase"), method_6468, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4465, type_4465, type_4465), Reflex::Literal("erase"), method_6469, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13524), Reflex::Literal("swap"), method_6470, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6471, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<int,std::allocator<int> > -------------------------------
static void constructor_6497( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>();
  else ::new(mem) ::std::vector<int>();
}

static void constructor_6498( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_6499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  }
}

static void constructor_6500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
}

static void destructor_6501(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<int>*)o)->::std::vector<int>::~vector)();
}
static  void operator_6502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
  else   (((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_6503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const int*)arg[1]);
}

static  void method_6504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->begin)());
  else   (((::std::vector<int>*)o)->begin)();
}

static  void method_6505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->begin)());
  else   (((const ::std::vector<int>*)o)->begin)();
}

static  void method_6506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->end)());
  else   (((::std::vector<int>*)o)->end)();
}

static  void method_6507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->end)());
  else   (((const ::std::vector<int>*)o)->end)();
}

static  void method_6512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->size)());
  else   (((const ::std::vector<int>*)o)->size)();
}

static  void method_6513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->max_size)());
  else   (((const ::std::vector<int>*)o)->max_size)();
}

static  void method_6514( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_6515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->capacity)());
  else   (((const ::std::vector<int>*)o)->capacity)();
}

static  void method_6516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<int>*)o)->empty)());
  else   (((const ::std::vector<int>*)o)->empty)();
}

static  void method_6517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->front)();
  else   (((::std::vector<int>*)o)->front)();
}

static  void method_6524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->front)();
  else   (((const ::std::vector<int>*)o)->front)();
}

static  void method_6525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->back)();
  else   (((::std::vector<int>*)o)->back)();
}

static  void method_6526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->back)();
  else   (((const ::std::vector<int>*)o)->back)();
}

static  void method_6527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<int>*)o)->data)());
  else   (((::std::vector<int>*)o)->data)();
}

static  void method_6528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<int>*)o)->data)());
  else   (((const ::std::vector<int>*)o)->data)();
}

static  void method_6529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->push_back)(*(const int*)arg[0]);
}

static  void method_6530( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->pop_back)();
}

static  void method_6531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]);
}

static  void method_6532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const int*)arg[2]);
}

static  void method_6533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]);
}

static  void method_6534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]);
}

static  void method_6535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->swap)(*(::std::vector<int>*)arg[0]);
}

static  void method_6536( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->clear)();
}

static void method_newdel_2269( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >")), ::Reflex::BaseOffset< ::std::vector<int>,::std::_Vector_base<int,std::allocator<int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<int> >::Generate();
}

//------Dictionary for class vector<int,std::allocator<int> > -------------------------------
void __std__vector_int__db_datamem(Reflex::Class*);
void __std__vector_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_int__datamem_bld(&__std__vector_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_int__funcmem_bld(&__std__vector_int__db_funcmem);
void __std__vector_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<int>"), typeid(::std::vector<int>), sizeof(::std::vector<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2225, ::Reflex::BaseOffset< ::std::vector<int>, ::std::_Vector_base<int,std::allocator<int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_114, Reflex::Literal("std::vector<int>::_Alloc_value_type"))
  .AddTypedef(type_2225, Reflex::Literal("std::vector<int>::_Base"))
  .AddTypedef(type_2695, Reflex::Literal("std::vector<int>::_Tp_alloc_type"))
  .AddTypedef(type_4518, Reflex::Literal("std::vector<int>::_Alloc_traits"))
  .AddTypedef(type_114, Reflex::Literal("std::vector<int>::value_type"))
  .AddTypedef(type_2979, Reflex::Literal("std::vector<int>::pointer"))
  .AddTypedef(type_6484, Reflex::Literal("std::vector<int>::const_pointer"))
  .AddTypedef(type_6486, Reflex::Literal("std::vector<int>::reference"))
  .AddTypedef(type_6488, Reflex::Literal("std::vector<int>::const_reference"))
  .AddTypedef(type_4467, Reflex::Literal("std::vector<int>::iterator"))
  .AddTypedef(type_4468, Reflex::Literal("std::vector<int>::const_iterator"))
  .AddTypedef(type_2792, Reflex::Literal("std::vector<int>::const_reverse_iterator"))
  .AddTypedef(type_2793, Reflex::Literal("std::vector<int>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<int>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<int>::difference_type"))
  .AddTypedef(type_2695, Reflex::Literal("std::vector<int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6497, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13367), Reflex::Literal("vector"), constructor_6498, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6488, type_13367), Reflex::Literal("vector"), constructor_6499, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13525), Reflex::Literal("vector"), constructor_6500, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6501, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2269, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_int__funcmem_bld);
}

//------Delayed data member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13526, type_13525), Reflex::Literal("operator="), operator_6502, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6488), Reflex::Literal("assign"), method_6503, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467), Reflex::Literal("begin"), method_6504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4468), Reflex::Literal("begin"), method_6505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467), Reflex::Literal("end"), method_6506, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4468), Reflex::Literal("end"), method_6507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_114), Reflex::Literal("resize"), method_6514, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6517, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6486, type_2662), Reflex::Literal("operator[]"), operator_6518, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6488, type_2662), Reflex::Literal("operator[]"), operator_6519, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6486, type_2662), Reflex::Literal("at"), method_6521, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6488, type_2662), Reflex::Literal("at"), method_6522, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6486), Reflex::Literal("front"), method_6523, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6488), Reflex::Literal("front"), method_6524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6486), Reflex::Literal("back"), method_6525, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6488), Reflex::Literal("back"), method_6526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2979), Reflex::Literal("data"), method_6527, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6484), Reflex::Literal("data"), method_6528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6488), Reflex::Literal("push_back"), method_6529, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6530, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467, type_4467, type_6488), Reflex::Literal("insert"), method_6531, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4467, type_2662, type_6488), Reflex::Literal("insert"), method_6532, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467, type_4467), Reflex::Literal("erase"), method_6533, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467, type_4467, type_4467), Reflex::Literal("erase"), method_6534, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13526), Reflex::Literal("swap"), method_6535, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6536, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class LBNE10ktPhotons -------------------------------
static void destructor_11255(void*, void * o, const std::vector<void*>&, void *) {
(((::sim::LBNE10ktPhotons*)o)->::sim::LBNE10ktPhotons::~LBNE10ktPhotons)();
}
static  void operator_11256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::sim::LBNE10ktPhotons*)o)->operator=)(*(const ::sim::LBNE10ktPhotons*)arg[0]);
  else   (((::sim::LBNE10ktPhotons*)o)->operator=)(*(const ::sim::LBNE10ktPhotons*)arg[0]);
}

static void constructor_11257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::LBNE10ktPhotons(*(const ::sim::LBNE10ktPhotons*)arg[0]);
  else ::new(mem) ::sim::LBNE10ktPhotons(*(const ::sim::LBNE10ktPhotons*)arg[0]);
}

static void constructor_11258( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::LBNE10ktPhotons();
  else ::new(mem) ::sim::LBNE10ktPhotons();
}

static void method_newdel_3552( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::sim::LBNE10ktPhotons >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::sim::LBNE10ktPhotons >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::sim::LBNE10ktPhotons >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::sim::LBNE10ktPhotons >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::sim::LBNE10ktPhotons >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LBNE10ktPhotons -------------------------------
void __sim__LBNE10ktPhotons_db_datamem(Reflex::Class*);
void __sim__LBNE10ktPhotons_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __sim__LBNE10ktPhotons_datamem_bld(&__sim__LBNE10ktPhotons_db_datamem);
Reflex::GenreflexMemberBuilder __sim__LBNE10ktPhotons_funcmem_bld(&__sim__LBNE10ktPhotons_db_funcmem);
void __sim__LBNE10ktPhotons_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("sim::LBNE10ktPhotons"), typeid(::sim::LBNE10ktPhotons), sizeof(::sim::LBNE10ktPhotons), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LBNE10ktPhotons"), destructor_11255, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6551, type_6553), Reflex::Literal("operator="), operator_11256, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6553), Reflex::Literal("LBNE10ktPhotons"), constructor_11257, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LBNE10ktPhotons"), constructor_11258, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3552, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__sim__LBNE10ktPhotons_datamem_bld);
}

//------Delayed data member builder for class LBNE10ktPhotons -------------------
void __sim__LBNE10ktPhotons_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_114, Reflex::Literal("OpChannel"), OffsetOf(__shadow__::__sim__LBNE10ktPhotons, OpChannel), ::Reflex::PUBLIC)
  .AddDataMember(type_2782, Reflex::Literal("DetectedPhotons"), OffsetOf(__shadow__::__sim__LBNE10ktPhotons, DetectedPhotons), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class LBNE10ktPhotons -------------------
void __sim__LBNE10ktPhotons_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > -------------------------------
static void constructor_6562( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::LBNE10ktPhotons>();
  else ::new(mem) ::std::vector<sim::LBNE10ktPhotons>();
}

static void constructor_6563( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(const ::std::allocator<sim::LBNE10ktPhotons>*)arg[0]);
  else ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(const ::std::allocator<sim::LBNE10ktPhotons>*)arg[0]);
}

static void constructor_6564( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::LBNE10ktPhotons*)arg[1]);
  else ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::LBNE10ktPhotons*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::LBNE10ktPhotons*)arg[1],
      *(const ::std::allocator<sim::LBNE10ktPhotons>*)arg[2]);
  else ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::LBNE10ktPhotons*)arg[1],
      *(const ::std::allocator<sim::LBNE10ktPhotons>*)arg[2]);
  }
}

static void constructor_6565( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(const ::std::vector<sim::LBNE10ktPhotons>*)arg[0]);
  else ::new(mem) ::std::vector<sim::LBNE10ktPhotons>(*(const ::std::vector<sim::LBNE10ktPhotons>*)arg[0]);
}

static void destructor_6566(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<sim::LBNE10ktPhotons>*)o)->::std::vector<sim::LBNE10ktPhotons>::~vector)();
}
static  void operator_6567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::LBNE10ktPhotons>*)o)->operator=)(*(const ::std::vector<sim::LBNE10ktPhotons>*)arg[0]);
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->operator=)(*(const ::std::vector<sim::LBNE10ktPhotons>*)arg[0]);
}

static  void method_6568( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::sim::LBNE10ktPhotons*)arg[1]);
}

static  void method_6569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((::std::vector<sim::LBNE10ktPhotons>*)o)->begin)());
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->begin)();
}

static  void method_6570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->begin)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->begin)();
}

static  void method_6571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((::std::vector<sim::LBNE10ktPhotons>*)o)->end)());
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->end)();
}

static  void method_6572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->end)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->end)();
}

static  void method_6577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->size)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->size)();
}

static  void method_6578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->max_size)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->max_size)();
}

static  void method_6579( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<sim::LBNE10ktPhotons>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<sim::LBNE10ktPhotons>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::sim::LBNE10ktPhotons*)arg[1]);
  }
}

static  void method_6580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->capacity)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->capacity)();
}

static  void method_6581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->empty)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->empty)();
}

static  void method_6582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::LBNE10ktPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::LBNE10ktPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::LBNE10ktPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::LBNE10ktPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::LBNE10ktPhotons>*)o)->front)();
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->front)();
}

static  void method_6589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::LBNE10ktPhotons>*)o)->front)();
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->front)();
}

static  void method_6590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::LBNE10ktPhotons>*)o)->back)();
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->back)();
}

static  void method_6591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::LBNE10ktPhotons>*)o)->back)();
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->back)();
}

static  void method_6592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<sim::LBNE10ktPhotons>*)o)->data)());
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->data)();
}

static  void method_6593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<sim::LBNE10ktPhotons>*)o)->data)());
  else   (((const ::std::vector<sim::LBNE10ktPhotons>*)o)->data)();
}

static  void method_6594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->push_back)(*(const ::sim::LBNE10ktPhotons*)arg[0]);
}

static  void method_6595( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->pop_back)();
}

static  void method_6596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((::std::vector<sim::LBNE10ktPhotons>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0],
    *(const ::sim::LBNE10ktPhotons*)arg[1]));
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0],
    *(const ::sim::LBNE10ktPhotons*)arg[1]);
}

static  void method_6597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::sim::LBNE10ktPhotons*)arg[2]);
}

static  void method_6598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((::std::vector<sim::LBNE10ktPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0]));
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0]);
}

static  void method_6599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >)((((::std::vector<sim::LBNE10ktPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[1]));
  else   (((::std::vector<sim::LBNE10ktPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::LBNE10ktPhotons*,std::vector<sim::LBNE10ktPhotons> >*)arg[1]);
}

static  void method_6600( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->swap)(*(::std::vector<sim::LBNE10ktPhotons>*)arg[0]);
}

static  void method_6601( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::LBNE10ktPhotons>*)o)->clear)();
}

static void method_newdel_2270( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<sim::LBNE10ktPhotons> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<sim::LBNE10ktPhotons> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<sim::LBNE10ktPhotons> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<sim::LBNE10ktPhotons> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<sim::LBNE10ktPhotons> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> >")), ::Reflex::BaseOffset< ::std::vector<sim::LBNE10ktPhotons>,::std::_Vector_base<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<sim::LBNE10ktPhotons> >::Generate();
  else ::Reflex::Proxy< ::std::vector<sim::LBNE10ktPhotons> >::Generate();
}

//------Dictionary for class vector<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > -------------------------------
void __std__vector_sim__LBNE10ktPhotons__db_datamem(Reflex::Class*);
void __std__vector_sim__LBNE10ktPhotons__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_sim__LBNE10ktPhotons__datamem_bld(&__std__vector_sim__LBNE10ktPhotons__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_sim__LBNE10ktPhotons__funcmem_bld(&__std__vector_sim__LBNE10ktPhotons__db_funcmem);
void __std__vector_sim__LBNE10ktPhotons__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<sim::LBNE10ktPhotons>"), typeid(::std::vector<sim::LBNE10ktPhotons>), sizeof(::std::vector<sim::LBNE10ktPhotons>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2226, ::Reflex::BaseOffset< ::std::vector<sim::LBNE10ktPhotons>, ::std::_Vector_base<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3552, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::_Alloc_value_type"))
  .AddTypedef(type_2226, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::_Base"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::_Tp_alloc_type"))
  .AddTypedef(type_4519, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::_Alloc_traits"))
  .AddTypedef(type_3552, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::value_type"))
  .AddTypedef(type_6142, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::pointer"))
  .AddTypedef(type_6549, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::const_pointer"))
  .AddTypedef(type_6551, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::reference"))
  .AddTypedef(type_6553, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::const_reference"))
  .AddTypedef(type_4469, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::iterator"))
  .AddTypedef(type_4470, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::const_iterator"))
  .AddTypedef(type_2794, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::const_reverse_iterator"))
  .AddTypedef(type_2795, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::difference_type"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<sim::LBNE10ktPhotons>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6562, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13380), Reflex::Literal("vector"), constructor_6563, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6553, type_13380), Reflex::Literal("vector"), constructor_6564, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13528), Reflex::Literal("vector"), constructor_6565, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6566, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2270, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_sim__LBNE10ktPhotons__funcmem_bld);
}

//------Delayed data member builder for class vector<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > -------------------
void __std__vector_sim__LBNE10ktPhotons__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<sim::LBNE10ktPhotons,std::allocator<sim::LBNE10ktPhotons> > -------------------
void __std__vector_sim__LBNE10ktPhotons__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13529, type_13528), Reflex::Literal("operator="), operator_6567, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6553), Reflex::Literal("assign"), method_6568, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469), Reflex::Literal("begin"), method_6569, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4470), Reflex::Literal("begin"), method_6570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469), Reflex::Literal("end"), method_6571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4470), Reflex::Literal("end"), method_6572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_3552), Reflex::Literal("resize"), method_6579, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6582, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6551, type_2662), Reflex::Literal("operator[]"), operator_6583, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6553, type_2662), Reflex::Literal("operator[]"), operator_6584, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6551, type_2662), Reflex::Literal("at"), method_6586, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6553, type_2662), Reflex::Literal("at"), method_6587, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6551), Reflex::Literal("front"), method_6588, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6553), Reflex::Literal("front"), method_6589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6551), Reflex::Literal("back"), method_6590, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6553), Reflex::Literal("back"), method_6591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6142), Reflex::Literal("data"), method_6592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6549), Reflex::Literal("data"), method_6593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6553), Reflex::Literal("push_back"), method_6594, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469, type_4469, type_6553), Reflex::Literal("insert"), method_6596, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4469, type_2662, type_6553), Reflex::Literal("insert"), method_6597, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469, type_4469), Reflex::Literal("erase"), method_6598, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469, type_4469, type_4469), Reflex::Literal("erase"), method_6599, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13529), Reflex::Literal("swap"), method_6600, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6601, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class OnePhoton -------------------------------
static void destructor_11234(void*, void * o, const std::vector<void*>&, void *) {
(((::sim::OnePhoton*)o)->::sim::OnePhoton::~OnePhoton)();
}
static  void operator_11235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::sim::OnePhoton*)o)->operator=)(*(const ::sim::OnePhoton*)arg[0]);
  else   (((::sim::OnePhoton*)o)->operator=)(*(const ::sim::OnePhoton*)arg[0]);
}

static void constructor_11236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::OnePhoton(*(const ::sim::OnePhoton*)arg[0]);
  else ::new(mem) ::sim::OnePhoton(*(const ::sim::OnePhoton*)arg[0]);
}

static void constructor_11237( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::OnePhoton();
  else ::new(mem) ::sim::OnePhoton();
}

static void method_newdel_3549( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::sim::OnePhoton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::sim::OnePhoton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::sim::OnePhoton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::sim::OnePhoton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::sim::OnePhoton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class OnePhoton -------------------------------
void __sim__OnePhoton_db_datamem(Reflex::Class*);
void __sim__OnePhoton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __sim__OnePhoton_datamem_bld(&__sim__OnePhoton_db_datamem);
Reflex::GenreflexMemberBuilder __sim__OnePhoton_funcmem_bld(&__sim__OnePhoton_db_funcmem);
void __sim__OnePhoton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("sim::OnePhoton"), typeid(::sim::OnePhoton), sizeof(::sim::OnePhoton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OnePhoton"), destructor_11234, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6616, type_6618), Reflex::Literal("operator="), operator_11235, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6618), Reflex::Literal("OnePhoton"), constructor_11236, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OnePhoton"), constructor_11237, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__sim__OnePhoton_datamem_bld);
}

//------Delayed data member builder for class OnePhoton -------------------
void __sim__OnePhoton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_504, Reflex::Literal("SetInSD"), OffsetOf(__shadow__::__sim__OnePhoton, SetInSD), ::Reflex::PUBLIC)
  .AddDataMember(type_1614, Reflex::Literal("InitialPosition"), OffsetOf(__shadow__::__sim__OnePhoton, InitialPosition), ::Reflex::PUBLIC)
  .AddDataMember(type_87, Reflex::Literal("Time"), OffsetOf(__shadow__::__sim__OnePhoton, Time), ::Reflex::PUBLIC)
  .AddDataMember(type_87, Reflex::Literal("Energy"), OffsetOf(__shadow__::__sim__OnePhoton, Energy), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class OnePhoton -------------------
void __sim__OnePhoton_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<sim::OnePhoton,std::allocator<sim::OnePhoton> > -------------------------------
static void constructor_6627( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::OnePhoton>();
  else ::new(mem) ::std::vector<sim::OnePhoton>();
}

static void constructor_6628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::OnePhoton>(*(const ::std::allocator<sim::OnePhoton>*)arg[0]);
  else ::new(mem) ::std::vector<sim::OnePhoton>(*(const ::std::allocator<sim::OnePhoton>*)arg[0]);
}

static void constructor_6629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::OnePhoton>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<sim::OnePhoton>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::OnePhoton>(*(::std::size_t*)arg[0],
      *(const ::sim::OnePhoton*)arg[1]);
  else ::new(mem) ::std::vector<sim::OnePhoton>(*(::std::size_t*)arg[0],
      *(const ::sim::OnePhoton*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::OnePhoton>(*(::std::size_t*)arg[0],
      *(const ::sim::OnePhoton*)arg[1],
      *(const ::std::allocator<sim::OnePhoton>*)arg[2]);
  else ::new(mem) ::std::vector<sim::OnePhoton>(*(::std::size_t*)arg[0],
      *(const ::sim::OnePhoton*)arg[1],
      *(const ::std::allocator<sim::OnePhoton>*)arg[2]);
  }
}

static void constructor_6630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::OnePhoton>(*(const ::std::vector<sim::OnePhoton>*)arg[0]);
  else ::new(mem) ::std::vector<sim::OnePhoton>(*(const ::std::vector<sim::OnePhoton>*)arg[0]);
}

static void destructor_6631(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<sim::OnePhoton>*)o)->::std::vector<sim::OnePhoton>::~vector)();
}
static  void operator_6632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::OnePhoton>*)o)->operator=)(*(const ::std::vector<sim::OnePhoton>*)arg[0]);
  else   (((::std::vector<sim::OnePhoton>*)o)->operator=)(*(const ::std::vector<sim::OnePhoton>*)arg[0]);
}

static  void method_6633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::sim::OnePhoton*)arg[1]);
}

static  void method_6634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((::std::vector<sim::OnePhoton>*)o)->begin)());
  else   (((::std::vector<sim::OnePhoton>*)o)->begin)();
}

static  void method_6635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((const ::std::vector<sim::OnePhoton>*)o)->begin)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->begin)();
}

static  void method_6636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((::std::vector<sim::OnePhoton>*)o)->end)());
  else   (((::std::vector<sim::OnePhoton>*)o)->end)();
}

static  void method_6637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((const ::std::vector<sim::OnePhoton>*)o)->end)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->end)();
}

static  void method_6642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::OnePhoton>*)o)->size)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->size)();
}

static  void method_6643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::OnePhoton>*)o)->max_size)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->max_size)();
}

static  void method_6644( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<sim::OnePhoton>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<sim::OnePhoton>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::sim::OnePhoton*)arg[1]);
  }
}

static  void method_6645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::OnePhoton>*)o)->capacity)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->capacity)();
}

static  void method_6646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<sim::OnePhoton>*)o)->empty)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->empty)();
}

static  void method_6647( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::OnePhoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::OnePhoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::OnePhoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::OnePhoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::OnePhoton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::OnePhoton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::OnePhoton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::OnePhoton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::OnePhoton>*)o)->front)();
  else   (((::std::vector<sim::OnePhoton>*)o)->front)();
}

static  void method_6654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::OnePhoton>*)o)->front)();
  else   (((const ::std::vector<sim::OnePhoton>*)o)->front)();
}

static  void method_6655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::OnePhoton>*)o)->back)();
  else   (((::std::vector<sim::OnePhoton>*)o)->back)();
}

static  void method_6656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::OnePhoton>*)o)->back)();
  else   (((const ::std::vector<sim::OnePhoton>*)o)->back)();
}

static  void method_6657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<sim::OnePhoton>*)o)->data)());
  else   (((::std::vector<sim::OnePhoton>*)o)->data)();
}

static  void method_6658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<sim::OnePhoton>*)o)->data)());
  else   (((const ::std::vector<sim::OnePhoton>*)o)->data)();
}

static  void method_6659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->push_back)(*(const ::sim::OnePhoton*)arg[0]);
}

static  void method_6660( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->pop_back)();
}

static  void method_6661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((::std::vector<sim::OnePhoton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0],
    *(const ::sim::OnePhoton*)arg[1]));
  else   (((::std::vector<sim::OnePhoton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0],
    *(const ::sim::OnePhoton*)arg[1]);
}

static  void method_6662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::sim::OnePhoton*)arg[2]);
}

static  void method_6663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((::std::vector<sim::OnePhoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0]));
  else   (((::std::vector<sim::OnePhoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0]);
}

static  void method_6664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >)((((::std::vector<sim::OnePhoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[1]));
  else   (((::std::vector<sim::OnePhoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::OnePhoton*,std::vector<sim::OnePhoton> >*)arg[1]);
}

static  void method_6665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->swap)(*(::std::vector<sim::OnePhoton>*)arg[0]);
}

static  void method_6666( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::OnePhoton>*)o)->clear)();
}

static void method_newdel_2271( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<sim::OnePhoton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<sim::OnePhoton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<sim::OnePhoton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<sim::OnePhoton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<sim::OnePhoton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> >")), ::Reflex::BaseOffset< ::std::vector<sim::OnePhoton>,::std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<sim::OnePhoton> >::Generate();
  else ::Reflex::Proxy< ::std::vector<sim::OnePhoton> >::Generate();
}

//------Dictionary for class vector<sim::OnePhoton,std::allocator<sim::OnePhoton> > -------------------------------
void __std__vector_sim__OnePhoton__db_datamem(Reflex::Class*);
void __std__vector_sim__OnePhoton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_sim__OnePhoton__datamem_bld(&__std__vector_sim__OnePhoton__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_sim__OnePhoton__funcmem_bld(&__std__vector_sim__OnePhoton__db_funcmem);
void __std__vector_sim__OnePhoton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<sim::OnePhoton>"), typeid(::std::vector<sim::OnePhoton>), sizeof(::std::vector<sim::OnePhoton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2230, ::Reflex::BaseOffset< ::std::vector<sim::OnePhoton>, ::std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3549, Reflex::Literal("std::vector<sim::OnePhoton>::_Alloc_value_type"))
  .AddTypedef(type_2230, Reflex::Literal("std::vector<sim::OnePhoton>::_Base"))
  .AddTypedef(type_2697, Reflex::Literal("std::vector<sim::OnePhoton>::_Tp_alloc_type"))
  .AddTypedef(type_4523, Reflex::Literal("std::vector<sim::OnePhoton>::_Alloc_traits"))
  .AddTypedef(type_3549, Reflex::Literal("std::vector<sim::OnePhoton>::value_type"))
  .AddTypedef(type_6218, Reflex::Literal("std::vector<sim::OnePhoton>::pointer"))
  .AddTypedef(type_6614, Reflex::Literal("std::vector<sim::OnePhoton>::const_pointer"))
  .AddTypedef(type_6616, Reflex::Literal("std::vector<sim::OnePhoton>::reference"))
  .AddTypedef(type_6618, Reflex::Literal("std::vector<sim::OnePhoton>::const_reference"))
  .AddTypedef(type_4477, Reflex::Literal("std::vector<sim::OnePhoton>::iterator"))
  .AddTypedef(type_4478, Reflex::Literal("std::vector<sim::OnePhoton>::const_iterator"))
  .AddTypedef(type_2804, Reflex::Literal("std::vector<sim::OnePhoton>::const_reverse_iterator"))
  .AddTypedef(type_2805, Reflex::Literal("std::vector<sim::OnePhoton>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<sim::OnePhoton>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<sim::OnePhoton>::difference_type"))
  .AddTypedef(type_2697, Reflex::Literal("std::vector<sim::OnePhoton>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6627, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13432), Reflex::Literal("vector"), constructor_6628, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6618, type_13432), Reflex::Literal("vector"), constructor_6629, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13531), Reflex::Literal("vector"), constructor_6630, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6631, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2271, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_sim__OnePhoton__funcmem_bld);
}

//------Delayed data member builder for class vector<sim::OnePhoton,std::allocator<sim::OnePhoton> > -------------------
void __std__vector_sim__OnePhoton__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<sim::OnePhoton,std::allocator<sim::OnePhoton> > -------------------
void __std__vector_sim__OnePhoton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13532, type_13531), Reflex::Literal("operator="), operator_6632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6618), Reflex::Literal("assign"), method_6633, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4477), Reflex::Literal("begin"), method_6634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4478), Reflex::Literal("begin"), method_6635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4477), Reflex::Literal("end"), method_6636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4478), Reflex::Literal("end"), method_6637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_3549), Reflex::Literal("resize"), method_6644, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6647, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6616, type_2662), Reflex::Literal("operator[]"), operator_6648, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6618, type_2662), Reflex::Literal("operator[]"), operator_6649, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6616, type_2662), Reflex::Literal("at"), method_6651, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6618, type_2662), Reflex::Literal("at"), method_6652, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6616), Reflex::Literal("front"), method_6653, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6618), Reflex::Literal("front"), method_6654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6616), Reflex::Literal("back"), method_6655, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6618), Reflex::Literal("back"), method_6656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6218), Reflex::Literal("data"), method_6657, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6614), Reflex::Literal("data"), method_6658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6618), Reflex::Literal("push_back"), method_6659, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4477, type_4477, type_6618), Reflex::Literal("insert"), method_6661, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4477, type_2662, type_6618), Reflex::Literal("insert"), method_6662, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4477, type_4477), Reflex::Literal("erase"), method_6663, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4477, type_4477, type_4477), Reflex::Literal("erase"), method_6664, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13532), Reflex::Literal("swap"), method_6665, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6666, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class SimPhotons -------------------------------
static void destructor_11226(void*, void * o, const std::vector<void*>&, void *) {
(((::sim::SimPhotons*)o)->::sim::SimPhotons::~SimPhotons)();
}
static  void operator_11227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::sim::SimPhotons*)o)->operator=)(*(const ::sim::SimPhotons*)arg[0]);
  else   (((::sim::SimPhotons*)o)->operator=)(*(const ::sim::SimPhotons*)arg[0]);
}

static void constructor_11228( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::SimPhotons(*(const ::sim::SimPhotons*)arg[0]);
  else ::new(mem) ::sim::SimPhotons(*(const ::sim::SimPhotons*)arg[0]);
}

static void constructor_11229( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::SimPhotons();
  else ::new(mem) ::sim::SimPhotons();
}

static void method_newdel_3548( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::sim::SimPhotons >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::sim::SimPhotons >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::sim::SimPhotons >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::sim::SimPhotons >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::sim::SimPhotons >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<sim::OnePhoton>")), ::Reflex::BaseOffset< ::sim::SimPhotons,::std::vector<sim::OnePhoton> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> >")), ::Reflex::BaseOffset< ::sim::SimPhotons,::std::_Vector_base<sim::OnePhoton,std::allocator<sim::OnePhoton> > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SimPhotons -------------------------------
void __sim__SimPhotons_db_datamem(Reflex::Class*);
void __sim__SimPhotons_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __sim__SimPhotons_datamem_bld(&__sim__SimPhotons_db_datamem);
Reflex::GenreflexMemberBuilder __sim__SimPhotons_funcmem_bld(&__sim__SimPhotons_db_funcmem);
void __sim__SimPhotons_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("sim::SimPhotons"), typeid(::sim::SimPhotons), sizeof(::sim::SimPhotons), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "12")
  .AddBase(type_2271, ::Reflex::BaseOffset< ::sim::SimPhotons, ::std::vector<sim::OnePhoton> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SimPhotons"), destructor_11226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681, type_6683), Reflex::Literal("operator="), operator_11227, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6683), Reflex::Literal("SimPhotons"), constructor_11228, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SimPhotons"), constructor_11229, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3548, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__sim__SimPhotons_datamem_bld);
}

//------Delayed data member builder for class SimPhotons -------------------
void __sim__SimPhotons_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_114, Reflex::Literal("fOpChannel"), OffsetOf(__shadow__::__sim__SimPhotons, fOpChannel), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class SimPhotons -------------------
void __sim__SimPhotons_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<sim::SimPhotons,std::allocator<sim::SimPhotons> > -------------------------------
static void constructor_6692( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimPhotons>();
  else ::new(mem) ::std::vector<sim::SimPhotons>();
}

static void constructor_6693( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimPhotons>(*(const ::std::allocator<sim::SimPhotons>*)arg[0]);
  else ::new(mem) ::std::vector<sim::SimPhotons>(*(const ::std::allocator<sim::SimPhotons>*)arg[0]);
}

static void constructor_6694( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimPhotons>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<sim::SimPhotons>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::SimPhotons*)arg[1]);
  else ::new(mem) ::std::vector<sim::SimPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::SimPhotons*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::SimPhotons*)arg[1],
      *(const ::std::allocator<sim::SimPhotons>*)arg[2]);
  else ::new(mem) ::std::vector<sim::SimPhotons>(*(::std::size_t*)arg[0],
      *(const ::sim::SimPhotons*)arg[1],
      *(const ::std::allocator<sim::SimPhotons>*)arg[2]);
  }
}

static void constructor_6695( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimPhotons>(*(const ::std::vector<sim::SimPhotons>*)arg[0]);
  else ::new(mem) ::std::vector<sim::SimPhotons>(*(const ::std::vector<sim::SimPhotons>*)arg[0]);
}

static void destructor_6696(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<sim::SimPhotons>*)o)->::std::vector<sim::SimPhotons>::~vector)();
}
static  void operator_6697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimPhotons>*)o)->operator=)(*(const ::std::vector<sim::SimPhotons>*)arg[0]);
  else   (((::std::vector<sim::SimPhotons>*)o)->operator=)(*(const ::std::vector<sim::SimPhotons>*)arg[0]);
}

static  void method_6698( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::sim::SimPhotons*)arg[1]);
}

static  void method_6699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((::std::vector<sim::SimPhotons>*)o)->begin)());
  else   (((::std::vector<sim::SimPhotons>*)o)->begin)();
}

static  void method_6700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((const ::std::vector<sim::SimPhotons>*)o)->begin)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->begin)();
}

static  void method_6701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((::std::vector<sim::SimPhotons>*)o)->end)());
  else   (((::std::vector<sim::SimPhotons>*)o)->end)();
}

static  void method_6702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((const ::std::vector<sim::SimPhotons>*)o)->end)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->end)();
}

static  void method_6707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::SimPhotons>*)o)->size)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->size)();
}

static  void method_6708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::SimPhotons>*)o)->max_size)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->max_size)();
}

static  void method_6709( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<sim::SimPhotons>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<sim::SimPhotons>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::sim::SimPhotons*)arg[1]);
  }
}

static  void method_6710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::SimPhotons>*)o)->capacity)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->capacity)();
}

static  void method_6711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<sim::SimPhotons>*)o)->empty)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->empty)();
}

static  void method_6712( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::SimPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::SimPhotons>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::SimPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::SimPhotons>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimPhotons>*)o)->front)();
  else   (((::std::vector<sim::SimPhotons>*)o)->front)();
}

static  void method_6719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimPhotons>*)o)->front)();
  else   (((const ::std::vector<sim::SimPhotons>*)o)->front)();
}

static  void method_6720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimPhotons>*)o)->back)();
  else   (((::std::vector<sim::SimPhotons>*)o)->back)();
}

static  void method_6721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimPhotons>*)o)->back)();
  else   (((const ::std::vector<sim::SimPhotons>*)o)->back)();
}

static  void method_6722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<sim::SimPhotons>*)o)->data)());
  else   (((::std::vector<sim::SimPhotons>*)o)->data)();
}

static  void method_6723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<sim::SimPhotons>*)o)->data)());
  else   (((const ::std::vector<sim::SimPhotons>*)o)->data)();
}

static  void method_6724( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->push_back)(*(const ::sim::SimPhotons*)arg[0]);
}

static  void method_6725( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->pop_back)();
}

static  void method_6726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((::std::vector<sim::SimPhotons>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0],
    *(const ::sim::SimPhotons*)arg[1]));
  else   (((::std::vector<sim::SimPhotons>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0],
    *(const ::sim::SimPhotons*)arg[1]);
}

static  void method_6727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::sim::SimPhotons*)arg[2]);
}

static  void method_6728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((::std::vector<sim::SimPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0]));
  else   (((::std::vector<sim::SimPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0]);
}

static  void method_6729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >)((((::std::vector<sim::SimPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[1]));
  else   (((::std::vector<sim::SimPhotons>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::SimPhotons*,std::vector<sim::SimPhotons> >*)arg[1]);
}

static  void method_6730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->swap)(*(::std::vector<sim::SimPhotons>*)arg[0]);
}

static  void method_6731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::SimPhotons>*)o)->clear)();
}

static void method_newdel_2272( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimPhotons> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimPhotons> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimPhotons> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimPhotons> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimPhotons> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::SimPhotons,std::allocator<sim::SimPhotons> >")), ::Reflex::BaseOffset< ::std::vector<sim::SimPhotons>,::std::_Vector_base<sim::SimPhotons,std::allocator<sim::SimPhotons> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<sim::SimPhotons> >::Generate();
  else ::Reflex::Proxy< ::std::vector<sim::SimPhotons> >::Generate();
}

//------Dictionary for class vector<sim::SimPhotons,std::allocator<sim::SimPhotons> > -------------------------------
void __std__vector_sim__SimPhotons__db_datamem(Reflex::Class*);
void __std__vector_sim__SimPhotons__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_sim__SimPhotons__datamem_bld(&__std__vector_sim__SimPhotons__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_sim__SimPhotons__funcmem_bld(&__std__vector_sim__SimPhotons__db_funcmem);
void __std__vector_sim__SimPhotons__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<sim::SimPhotons>"), typeid(::std::vector<sim::SimPhotons>), sizeof(::std::vector<sim::SimPhotons>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2227, ::Reflex::BaseOffset< ::std::vector<sim::SimPhotons>, ::std::_Vector_base<sim::SimPhotons,std::allocator<sim::SimPhotons> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3548, Reflex::Literal("std::vector<sim::SimPhotons>::_Alloc_value_type"))
  .AddTypedef(type_2227, Reflex::Literal("std::vector<sim::SimPhotons>::_Base"))
  .AddTypedef(type_2698, Reflex::Literal("std::vector<sim::SimPhotons>::_Tp_alloc_type"))
  .AddTypedef(type_4520, Reflex::Literal("std::vector<sim::SimPhotons>::_Alloc_traits"))
  .AddTypedef(type_3548, Reflex::Literal("std::vector<sim::SimPhotons>::value_type"))
  .AddTypedef(type_6161, Reflex::Literal("std::vector<sim::SimPhotons>::pointer"))
  .AddTypedef(type_6679, Reflex::Literal("std::vector<sim::SimPhotons>::const_pointer"))
  .AddTypedef(type_6681, Reflex::Literal("std::vector<sim::SimPhotons>::reference"))
  .AddTypedef(type_6683, Reflex::Literal("std::vector<sim::SimPhotons>::const_reference"))
  .AddTypedef(type_4471, Reflex::Literal("std::vector<sim::SimPhotons>::iterator"))
  .AddTypedef(type_4472, Reflex::Literal("std::vector<sim::SimPhotons>::const_iterator"))
  .AddTypedef(type_2796, Reflex::Literal("std::vector<sim::SimPhotons>::const_reverse_iterator"))
  .AddTypedef(type_2797, Reflex::Literal("std::vector<sim::SimPhotons>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<sim::SimPhotons>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<sim::SimPhotons>::difference_type"))
  .AddTypedef(type_2698, Reflex::Literal("std::vector<sim::SimPhotons>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6692, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13393), Reflex::Literal("vector"), constructor_6693, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6683, type_13393), Reflex::Literal("vector"), constructor_6694, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13534), Reflex::Literal("vector"), constructor_6695, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6696, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2272, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_sim__SimPhotons__funcmem_bld);
}

//------Delayed data member builder for class vector<sim::SimPhotons,std::allocator<sim::SimPhotons> > -------------------
void __std__vector_sim__SimPhotons__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<sim::SimPhotons,std::allocator<sim::SimPhotons> > -------------------
void __std__vector_sim__SimPhotons__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13535, type_13534), Reflex::Literal("operator="), operator_6697, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6683), Reflex::Literal("assign"), method_6698, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4471), Reflex::Literal("begin"), method_6699, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4472), Reflex::Literal("begin"), method_6700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4471), Reflex::Literal("end"), method_6701, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4472), Reflex::Literal("end"), method_6702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_3548), Reflex::Literal("resize"), method_6709, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6712, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681, type_2662), Reflex::Literal("operator[]"), operator_6713, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683, type_2662), Reflex::Literal("operator[]"), operator_6714, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681, type_2662), Reflex::Literal("at"), method_6716, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683, type_2662), Reflex::Literal("at"), method_6717, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681), Reflex::Literal("front"), method_6718, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683), Reflex::Literal("front"), method_6719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6681), Reflex::Literal("back"), method_6720, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6683), Reflex::Literal("back"), method_6721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6161), Reflex::Literal("data"), method_6722, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6679), Reflex::Literal("data"), method_6723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6683), Reflex::Literal("push_back"), method_6724, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4471, type_4471, type_6683), Reflex::Literal("insert"), method_6726, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4471, type_2662, type_6683), Reflex::Literal("insert"), method_6727, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4471, type_4471), Reflex::Literal("erase"), method_6728, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4471, type_4471, type_4471), Reflex::Literal("erase"), method_6729, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13535), Reflex::Literal("swap"), method_6730, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6731, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class SimChannel -------------------------------
static void destructor_11267(void*, void * o, const std::vector<void*>&, void *) {
(((::sim::SimChannel*)o)->::sim::SimChannel::~SimChannel)();
}
static  void operator_11268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::sim::SimChannel*)o)->operator=)(*(const ::sim::SimChannel*)arg[0]);
  else   (((::sim::SimChannel*)o)->operator=)(*(const ::sim::SimChannel*)arg[0]);
}

static void constructor_11269( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::SimChannel(*(const ::sim::SimChannel*)arg[0]);
  else ::new(mem) ::sim::SimChannel(*(const ::sim::SimChannel*)arg[0]);
}

static void constructor_11270( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::SimChannel();
  else ::new(mem) ::sim::SimChannel();
}

static void method_newdel_3554( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::sim::SimChannel >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::sim::SimChannel >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::sim::SimChannel >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::sim::SimChannel >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::sim::SimChannel >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___sim__SimChannel_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_fChannel = oldObj->GetId("fChannel");
#endif
  struct __sim__SimChannel_Onfile {
    unsigned short &fChannel;
    __sim__SimChannel_Onfile( unsigned short &onfile_fChannel ): fChannel(onfile_fChannel){}
  };
  static Long_t offset_Onfile___sim__SimChannel_fChannel = oldObj->GetClass()->GetDataMemberOffset("fChannel");
  char *onfile_add = (char*)oldObj->GetObject();
  __sim__SimChannel_Onfile onfile(
         *(unsigned short*)(onfile_add+offset_Onfile___sim__SimChannel_fChannel) );

  uint32_t &fChannel = *(uint32_t*)(target + OffsetOf(__shadow__::__sim__SimChannel, fChannel));

  //--- User's code ---
    fChannel = onfile.fChannel;
}

//------Dictionary for class SimChannel -------------------------------
void __sim__SimChannel_db_datamem(Reflex::Class*);
void __sim__SimChannel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __sim__SimChannel_datamem_bld(&__sim__SimChannel_db_datamem);
Reflex::GenreflexMemberBuilder __sim__SimChannel_funcmem_bld(&__sim__SimChannel_db_funcmem);
void __sim__SimChannel_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "sim::SimChannel";
  rule->fTarget      = "fChannel";
  rule->fSource      = "unsigned short fChannel";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___sim__SimChannel_0);
  rule->fCode        = "\n    fChannel = onfile.fChannel;\n";
  rule->fVersion     = "[-13]";
  rule->fInclude     = "SimChannel.h";


  ::Reflex::ClassBuilder(Reflex::Literal("sim::SimChannel"), typeid(::sim::SimChannel), sizeof(::sim::SimChannel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "14")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SimChannel"), destructor_11267, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6746, type_6748), Reflex::Literal("operator="), operator_11268, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6748), Reflex::Literal("SimChannel"), constructor_11269, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SimChannel"), constructor_11270, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3554, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__sim__SimChannel_datamem_bld);
}

//------Delayed data member builder for class SimChannel -------------------
void __sim__SimChannel_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_443, Reflex::Literal("fChannel"), OffsetOf(__shadow__::__sim__SimChannel, fChannel), ::Reflex::PRIVATE)
  .AddDataMember(type_2783, Reflex::Literal("fTDCIDEs"), OffsetOf(__shadow__::__sim__SimChannel, fTDCIDEs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SimChannel -------------------
void __sim__SimChannel_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<sim::SimChannel,std::allocator<sim::SimChannel> > -------------------------------
static void constructor_6757( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimChannel>();
  else ::new(mem) ::std::vector<sim::SimChannel>();
}

static void constructor_6758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimChannel>(*(const ::std::allocator<sim::SimChannel>*)arg[0]);
  else ::new(mem) ::std::vector<sim::SimChannel>(*(const ::std::allocator<sim::SimChannel>*)arg[0]);
}

static void constructor_6759( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimChannel>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<sim::SimChannel>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimChannel>(*(::std::size_t*)arg[0],
      *(const ::sim::SimChannel*)arg[1]);
  else ::new(mem) ::std::vector<sim::SimChannel>(*(::std::size_t*)arg[0],
      *(const ::sim::SimChannel*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimChannel>(*(::std::size_t*)arg[0],
      *(const ::sim::SimChannel*)arg[1],
      *(const ::std::allocator<sim::SimChannel>*)arg[2]);
  else ::new(mem) ::std::vector<sim::SimChannel>(*(::std::size_t*)arg[0],
      *(const ::sim::SimChannel*)arg[1],
      *(const ::std::allocator<sim::SimChannel>*)arg[2]);
  }
}

static void constructor_6760( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::SimChannel>(*(const ::std::vector<sim::SimChannel>*)arg[0]);
  else ::new(mem) ::std::vector<sim::SimChannel>(*(const ::std::vector<sim::SimChannel>*)arg[0]);
}

static void destructor_6761(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<sim::SimChannel>*)o)->::std::vector<sim::SimChannel>::~vector)();
}
static  void operator_6762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimChannel>*)o)->operator=)(*(const ::std::vector<sim::SimChannel>*)arg[0]);
  else   (((::std::vector<sim::SimChannel>*)o)->operator=)(*(const ::std::vector<sim::SimChannel>*)arg[0]);
}

static  void method_6763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::sim::SimChannel*)arg[1]);
}

static  void method_6764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >)((((::std::vector<sim::SimChannel>*)o)->begin)());
  else   (((::std::vector<sim::SimChannel>*)o)->begin)();
}

static  void method_6765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::SimChannel*,std::vector<sim::SimChannel> >)((((const ::std::vector<sim::SimChannel>*)o)->begin)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->begin)();
}

static  void method_6766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >)((((::std::vector<sim::SimChannel>*)o)->end)());
  else   (((::std::vector<sim::SimChannel>*)o)->end)();
}

static  void method_6767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::SimChannel*,std::vector<sim::SimChannel> >)((((const ::std::vector<sim::SimChannel>*)o)->end)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->end)();
}

static  void method_6772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::SimChannel>*)o)->size)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->size)();
}

static  void method_6773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::SimChannel>*)o)->max_size)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->max_size)();
}

static  void method_6774( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<sim::SimChannel>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<sim::SimChannel>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::sim::SimChannel*)arg[1]);
  }
}

static  void method_6775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::SimChannel>*)o)->capacity)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->capacity)();
}

static  void method_6776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<sim::SimChannel>*)o)->empty)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->empty)();
}

static  void method_6777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimChannel>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::SimChannel>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimChannel>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::SimChannel>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimChannel>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::SimChannel>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimChannel>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::SimChannel>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimChannel>*)o)->front)();
  else   (((::std::vector<sim::SimChannel>*)o)->front)();
}

static  void method_6784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimChannel>*)o)->front)();
  else   (((const ::std::vector<sim::SimChannel>*)o)->front)();
}

static  void method_6785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::SimChannel>*)o)->back)();
  else   (((::std::vector<sim::SimChannel>*)o)->back)();
}

static  void method_6786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::SimChannel>*)o)->back)();
  else   (((const ::std::vector<sim::SimChannel>*)o)->back)();
}

static  void method_6787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<sim::SimChannel>*)o)->data)());
  else   (((::std::vector<sim::SimChannel>*)o)->data)();
}

static  void method_6788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<sim::SimChannel>*)o)->data)());
  else   (((const ::std::vector<sim::SimChannel>*)o)->data)();
}

static  void method_6789( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->push_back)(*(const ::sim::SimChannel*)arg[0]);
}

static  void method_6790( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->pop_back)();
}

static  void method_6791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >)((((::std::vector<sim::SimChannel>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0],
    *(const ::sim::SimChannel*)arg[1]));
  else   (((::std::vector<sim::SimChannel>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0],
    *(const ::sim::SimChannel*)arg[1]);
}

static  void method_6792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::sim::SimChannel*)arg[2]);
}

static  void method_6793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >)((((::std::vector<sim::SimChannel>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0]));
  else   (((::std::vector<sim::SimChannel>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0]);
}

static  void method_6794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >)((((::std::vector<sim::SimChannel>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[1]));
  else   (((::std::vector<sim::SimChannel>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::SimChannel*,std::vector<sim::SimChannel> >*)arg[1]);
}

static  void method_6795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->swap)(*(::std::vector<sim::SimChannel>*)arg[0]);
}

static  void method_6796( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::SimChannel>*)o)->clear)();
}

static void method_newdel_2273( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimChannel> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimChannel> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimChannel> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimChannel> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<sim::SimChannel> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::SimChannel,std::allocator<sim::SimChannel> >")), ::Reflex::BaseOffset< ::std::vector<sim::SimChannel>,::std::_Vector_base<sim::SimChannel,std::allocator<sim::SimChannel> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<sim::SimChannel> >::Generate();
  else ::Reflex::Proxy< ::std::vector<sim::SimChannel> >::Generate();
}

//------Dictionary for class vector<sim::SimChannel,std::allocator<sim::SimChannel> > -------------------------------
void __std__vector_sim__SimChannel__db_datamem(Reflex::Class*);
void __std__vector_sim__SimChannel__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_sim__SimChannel__datamem_bld(&__std__vector_sim__SimChannel__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_sim__SimChannel__funcmem_bld(&__std__vector_sim__SimChannel__db_funcmem);
void __std__vector_sim__SimChannel__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<sim::SimChannel>"), typeid(::std::vector<sim::SimChannel>), sizeof(::std::vector<sim::SimChannel>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2228, ::Reflex::BaseOffset< ::std::vector<sim::SimChannel>, ::std::_Vector_base<sim::SimChannel,std::allocator<sim::SimChannel> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3554, Reflex::Literal("std::vector<sim::SimChannel>::_Alloc_value_type"))
  .AddTypedef(type_2228, Reflex::Literal("std::vector<sim::SimChannel>::_Base"))
  .AddTypedef(type_2699, Reflex::Literal("std::vector<sim::SimChannel>::_Tp_alloc_type"))
  .AddTypedef(type_4521, Reflex::Literal("std::vector<sim::SimChannel>::_Alloc_traits"))
  .AddTypedef(type_3554, Reflex::Literal("std::vector<sim::SimChannel>::value_type"))
  .AddTypedef(type_6180, Reflex::Literal("std::vector<sim::SimChannel>::pointer"))
  .AddTypedef(type_6744, Reflex::Literal("std::vector<sim::SimChannel>::const_pointer"))
  .AddTypedef(type_6746, Reflex::Literal("std::vector<sim::SimChannel>::reference"))
  .AddTypedef(type_6748, Reflex::Literal("std::vector<sim::SimChannel>::const_reference"))
  .AddTypedef(type_4473, Reflex::Literal("std::vector<sim::SimChannel>::iterator"))
  .AddTypedef(type_4474, Reflex::Literal("std::vector<sim::SimChannel>::const_iterator"))
  .AddTypedef(type_2798, Reflex::Literal("std::vector<sim::SimChannel>::const_reverse_iterator"))
  .AddTypedef(type_2799, Reflex::Literal("std::vector<sim::SimChannel>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<sim::SimChannel>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<sim::SimChannel>::difference_type"))
  .AddTypedef(type_2699, Reflex::Literal("std::vector<sim::SimChannel>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6757, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13406), Reflex::Literal("vector"), constructor_6758, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6748, type_13406), Reflex::Literal("vector"), constructor_6759, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13537), Reflex::Literal("vector"), constructor_6760, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6761, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2273, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_sim__SimChannel__funcmem_bld);
}

//------Delayed data member builder for class vector<sim::SimChannel,std::allocator<sim::SimChannel> > -------------------
void __std__vector_sim__SimChannel__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<sim::SimChannel,std::allocator<sim::SimChannel> > -------------------
void __std__vector_sim__SimChannel__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13538, type_13537), Reflex::Literal("operator="), operator_6762, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6748), Reflex::Literal("assign"), method_6763, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4473), Reflex::Literal("begin"), method_6764, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4474), Reflex::Literal("begin"), method_6765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4473), Reflex::Literal("end"), method_6766, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4474), Reflex::Literal("end"), method_6767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_3554), Reflex::Literal("resize"), method_6774, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6777, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6746, type_2662), Reflex::Literal("operator[]"), operator_6778, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6748, type_2662), Reflex::Literal("operator[]"), operator_6779, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6746, type_2662), Reflex::Literal("at"), method_6781, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6748, type_2662), Reflex::Literal("at"), method_6782, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6746), Reflex::Literal("front"), method_6783, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6748), Reflex::Literal("front"), method_6784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6746), Reflex::Literal("back"), method_6785, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6748), Reflex::Literal("back"), method_6786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6180), Reflex::Literal("data"), method_6787, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6744), Reflex::Literal("data"), method_6788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6748), Reflex::Literal("push_back"), method_6789, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4473, type_4473, type_6748), Reflex::Literal("insert"), method_6791, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4473, type_2662, type_6748), Reflex::Literal("insert"), method_6792, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4473, type_4473), Reflex::Literal("erase"), method_6793, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4473, type_4473, type_4473), Reflex::Literal("erase"), method_6794, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13538), Reflex::Literal("swap"), method_6795, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6796, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class IDE -------------------------------
static void destructor_11249(void*, void * o, const std::vector<void*>&, void *) {
(((::sim::IDE*)o)->::sim::IDE::~IDE)();
}
static  void operator_11250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::sim::IDE*)o)->operator=)(*(const ::sim::IDE*)arg[0]);
  else   (((::sim::IDE*)o)->operator=)(*(const ::sim::IDE*)arg[0]);
}

static void constructor_11251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::IDE(*(const ::sim::IDE*)arg[0]);
  else ::new(mem) ::sim::IDE(*(const ::sim::IDE*)arg[0]);
}

static void constructor_11252( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::sim::IDE();
  else ::new(mem) ::sim::IDE();
}

static void method_newdel_3551( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::sim::IDE >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::sim::IDE >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::sim::IDE >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::sim::IDE >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::sim::IDE >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class IDE -------------------------------
void __sim__IDE_db_datamem(Reflex::Class*);
void __sim__IDE_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __sim__IDE_datamem_bld(&__sim__IDE_db_datamem);
Reflex::GenreflexMemberBuilder __sim__IDE_funcmem_bld(&__sim__IDE_db_funcmem);
void __sim__IDE_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("sim::IDE"), typeid(::sim::IDE), sizeof(::sim::IDE), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IDE"), destructor_11249, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6811, type_6813), Reflex::Literal("operator="), operator_11250, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6813), Reflex::Literal("IDE"), constructor_11251, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IDE"), constructor_11252, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3551, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__sim__IDE_datamem_bld);
}

//------Delayed data member builder for class IDE -------------------
void __sim__IDE_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_114, Reflex::Literal("trackID"), OffsetOf(__shadow__::__sim__IDE, trackID), ::Reflex::PUBLIC)
  .AddDataMember(type_185, Reflex::Literal("numElectrons"), OffsetOf(__shadow__::__sim__IDE, numElectrons), ::Reflex::PUBLIC)
  .AddDataMember(type_185, Reflex::Literal("energy"), OffsetOf(__shadow__::__sim__IDE, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_185, Reflex::Literal("x"), OffsetOf(__shadow__::__sim__IDE, x), ::Reflex::PUBLIC)
  .AddDataMember(type_185, Reflex::Literal("y"), OffsetOf(__shadow__::__sim__IDE, y), ::Reflex::PUBLIC)
  .AddDataMember(type_185, Reflex::Literal("z"), OffsetOf(__shadow__::__sim__IDE, z), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class IDE -------------------
void __sim__IDE_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<sim::IDE,std::allocator<sim::IDE> > -------------------------------
static void constructor_6822( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::IDE>();
  else ::new(mem) ::std::vector<sim::IDE>();
}

static void constructor_6823( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::IDE>(*(const ::std::allocator<sim::IDE>*)arg[0]);
  else ::new(mem) ::std::vector<sim::IDE>(*(const ::std::allocator<sim::IDE>*)arg[0]);
}

static void constructor_6824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::IDE>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<sim::IDE>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::IDE>(*(::std::size_t*)arg[0],
      *(const ::sim::IDE*)arg[1]);
  else ::new(mem) ::std::vector<sim::IDE>(*(::std::size_t*)arg[0],
      *(const ::sim::IDE*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::IDE>(*(::std::size_t*)arg[0],
      *(const ::sim::IDE*)arg[1],
      *(const ::std::allocator<sim::IDE>*)arg[2]);
  else ::new(mem) ::std::vector<sim::IDE>(*(::std::size_t*)arg[0],
      *(const ::sim::IDE*)arg[1],
      *(const ::std::allocator<sim::IDE>*)arg[2]);
  }
}

static void constructor_6825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<sim::IDE>(*(const ::std::vector<sim::IDE>*)arg[0]);
  else ::new(mem) ::std::vector<sim::IDE>(*(const ::std::vector<sim::IDE>*)arg[0]);
}

static void destructor_6826(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<sim::IDE>*)o)->::std::vector<sim::IDE>::~vector)();
}
static  void operator_6827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::IDE>*)o)->operator=)(*(const ::std::vector<sim::IDE>*)arg[0]);
  else   (((::std::vector<sim::IDE>*)o)->operator=)(*(const ::std::vector<sim::IDE>*)arg[0]);
}

static  void method_6828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::IDE>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::sim::IDE*)arg[1]);
}

static  void method_6829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >)((((::std::vector<sim::IDE>*)o)->begin)());
  else   (((::std::vector<sim::IDE>*)o)->begin)();
}

static  void method_6830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::IDE*,std::vector<sim::IDE> >)((((const ::std::vector<sim::IDE>*)o)->begin)());
  else   (((const ::std::vector<sim::IDE>*)o)->begin)();
}

static  void method_6831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >)((((::std::vector<sim::IDE>*)o)->end)());
  else   (((::std::vector<sim::IDE>*)o)->end)();
}

static  void method_6832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const sim::IDE*,std::vector<sim::IDE> >)((((const ::std::vector<sim::IDE>*)o)->end)());
  else   (((const ::std::vector<sim::IDE>*)o)->end)();
}

static  void method_6837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::IDE>*)o)->size)());
  else   (((const ::std::vector<sim::IDE>*)o)->size)();
}

static  void method_6838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::IDE>*)o)->max_size)());
  else   (((const ::std::vector<sim::IDE>*)o)->max_size)();
}

static  void method_6839( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<sim::IDE>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<sim::IDE>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::sim::IDE*)arg[1]);
  }
}

static  void method_6840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<sim::IDE>*)o)->capacity)());
  else   (((const ::std::vector<sim::IDE>*)o)->capacity)();
}

static  void method_6841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<sim::IDE>*)o)->empty)());
  else   (((const ::std::vector<sim::IDE>*)o)->empty)();
}

static  void method_6842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::IDE>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::IDE>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::IDE>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::IDE>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::IDE>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::IDE>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<sim::IDE>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::IDE>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<sim::IDE>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::IDE>*)o)->front)();
  else   (((::std::vector<sim::IDE>*)o)->front)();
}

static  void method_6849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::IDE>*)o)->front)();
  else   (((const ::std::vector<sim::IDE>*)o)->front)();
}

static  void method_6850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<sim::IDE>*)o)->back)();
  else   (((::std::vector<sim::IDE>*)o)->back)();
}

static  void method_6851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<sim::IDE>*)o)->back)();
  else   (((const ::std::vector<sim::IDE>*)o)->back)();
}

static  void method_6852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<sim::IDE>*)o)->data)());
  else   (((::std::vector<sim::IDE>*)o)->data)();
}

static  void method_6853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<sim::IDE>*)o)->data)());
  else   (((const ::std::vector<sim::IDE>*)o)->data)();
}

static  void method_6854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::IDE>*)o)->push_back)(*(const ::sim::IDE*)arg[0]);
}

static  void method_6855( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::IDE>*)o)->pop_back)();
}

static  void method_6856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >)((((::std::vector<sim::IDE>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0],
    *(const ::sim::IDE*)arg[1]));
  else   (((::std::vector<sim::IDE>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0],
    *(const ::sim::IDE*)arg[1]);
}

static  void method_6857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::IDE>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::sim::IDE*)arg[2]);
}

static  void method_6858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >)((((::std::vector<sim::IDE>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0]));
  else   (((::std::vector<sim::IDE>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0]);
}

static  void method_6859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >)((((::std::vector<sim::IDE>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[1]));
  else   (((::std::vector<sim::IDE>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<sim::IDE*,std::vector<sim::IDE> >*)arg[1]);
}

static  void method_6860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<sim::IDE>*)o)->swap)(*(::std::vector<sim::IDE>*)arg[0]);
}

static  void method_6861( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<sim::IDE>*)o)->clear)();
}

static void method_newdel_2274( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<sim::IDE> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<sim::IDE> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<sim::IDE> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<sim::IDE> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<sim::IDE> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<sim::IDE,std::allocator<sim::IDE> >")), ::Reflex::BaseOffset< ::std::vector<sim::IDE>,::std::_Vector_base<sim::IDE,std::allocator<sim::IDE> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<sim::IDE> >::Generate();
  else ::Reflex::Proxy< ::std::vector<sim::IDE> >::Generate();
}

//------Dictionary for class vector<sim::IDE,std::allocator<sim::IDE> > -------------------------------
void __std__vector_sim__IDE__db_datamem(Reflex::Class*);
void __std__vector_sim__IDE__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_sim__IDE__datamem_bld(&__std__vector_sim__IDE__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_sim__IDE__funcmem_bld(&__std__vector_sim__IDE__db_funcmem);
void __std__vector_sim__IDE__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<sim::IDE>"), typeid(::std::vector<sim::IDE>), sizeof(::std::vector<sim::IDE>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2229, ::Reflex::BaseOffset< ::std::vector<sim::IDE>, ::std::_Vector_base<sim::IDE,std::allocator<sim::IDE> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3551, Reflex::Literal("std::vector<sim::IDE>::_Alloc_value_type"))
  .AddTypedef(type_2229, Reflex::Literal("std::vector<sim::IDE>::_Base"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<sim::IDE>::_Tp_alloc_type"))
  .AddTypedef(type_4522, Reflex::Literal("std::vector<sim::IDE>::_Alloc_traits"))
  .AddTypedef(type_3551, Reflex::Literal("std::vector<sim::IDE>::value_type"))
  .AddTypedef(type_6199, Reflex::Literal("std::vector<sim::IDE>::pointer"))
  .AddTypedef(type_6809, Reflex::Literal("std::vector<sim::IDE>::const_pointer"))
  .AddTypedef(type_6811, Reflex::Literal("std::vector<sim::IDE>::reference"))
  .AddTypedef(type_6813, Reflex::Literal("std::vector<sim::IDE>::const_reference"))
  .AddTypedef(type_4475, Reflex::Literal("std::vector<sim::IDE>::iterator"))
  .AddTypedef(type_4476, Reflex::Literal("std::vector<sim::IDE>::const_iterator"))
  .AddTypedef(type_2800, Reflex::Literal("std::vector<sim::IDE>::const_reverse_iterator"))
  .AddTypedef(type_2801, Reflex::Literal("std::vector<sim::IDE>::reverse_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::vector<sim::IDE>::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::vector<sim::IDE>::difference_type"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<sim::IDE>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6822, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13419), Reflex::Literal("vector"), constructor_6823, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2662, type_6813, type_13419), Reflex::Literal("vector"), constructor_6824, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13540), Reflex::Literal("vector"), constructor_6825, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6826, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2274, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_sim__IDE__funcmem_bld);
}

//------Delayed data member builder for class vector<sim::IDE,std::allocator<sim::IDE> > -------------------
void __std__vector_sim__IDE__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<sim::IDE,std::allocator<sim::IDE> > -------------------
void __std__vector_sim__IDE__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13541, type_13540), Reflex::Literal("operator="), operator_6827, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_6813), Reflex::Literal("assign"), method_6828, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4475), Reflex::Literal("begin"), method_6829, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4476), Reflex::Literal("begin"), method_6830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4475), Reflex::Literal("end"), method_6831, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4476), Reflex::Literal("end"), method_6832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_6837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_6838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662, type_3551), Reflex::Literal("resize"), method_6839, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("capacity"), method_6840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_6841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2662), Reflex::Literal("reserve"), method_6842, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6811, type_2662), Reflex::Literal("operator[]"), operator_6843, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6813, type_2662), Reflex::Literal("operator[]"), operator_6844, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6811, type_2662), Reflex::Literal("at"), method_6846, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6813, type_2662), Reflex::Literal("at"), method_6847, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6811), Reflex::Literal("front"), method_6848, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6813), Reflex::Literal("front"), method_6849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6811), Reflex::Literal("back"), method_6850, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6813), Reflex::Literal("back"), method_6851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6199), Reflex::Literal("data"), method_6852, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6809), Reflex::Literal("data"), method_6853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_6813), Reflex::Literal("push_back"), method_6854, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("pop_back"), method_6855, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4475, type_4475, type_6813), Reflex::Literal("insert"), method_6856, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_4475, type_2662, type_6813), Reflex::Literal("insert"), method_6857, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4475, type_4475), Reflex::Literal("erase"), method_6858, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4475, type_4475, type_4475), Reflex::Literal("erase"), method_6859, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_13541), Reflex::Literal("swap"), method_6860, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_6861, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class pair<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> > > -------------------------------
static void destructor_9219(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned short,std::vector<sim::IDE> >*)o)->::std::pair<unsigned short,std::vector<sim::IDE> >::~pair)();
}
static  void operator_9220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned short,std::vector<sim::IDE> >*)o)->operator=)(*(const ::std::pair<unsigned short,std::vector<sim::IDE> >*)arg[0]);
  else   (((::std::pair<unsigned short,std::vector<sim::IDE> >*)o)->operator=)(*(const ::std::pair<unsigned short,std::vector<sim::IDE> >*)arg[0]);
}

static void constructor_9221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,std::vector<sim::IDE> >(*(const ::std::pair<unsigned short,std::vector<sim::IDE> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned short,std::vector<sim::IDE> >(*(const ::std::pair<unsigned short,std::vector<sim::IDE> >*)arg[0]);
}

static void constructor_9222( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,std::vector<sim::IDE> >();
  else ::new(mem) ::std::pair<unsigned short,std::vector<sim::IDE> >();
}

static void constructor_9223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,std::vector<sim::IDE> >(*(const unsigned short*)arg[0],
      *(const ::std::vector<sim::IDE>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned short,std::vector<sim::IDE> >(*(const unsigned short*)arg[0],
      *(const ::std::vector<sim::IDE>*)arg[1]);
}

static void method_newdel_2625( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<sim::IDE> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<sim::IDE> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<sim::IDE> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<sim::IDE> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<sim::IDE> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> > > -------------------------------
void __std__pair_unsignedsshort_std__vector_sim__IDE_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsshort_std__vector_sim__IDE_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_std__vector_sim__IDE_s__datamem_bld(&__std__pair_unsignedsshort_std__vector_sim__IDE_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_std__vector_sim__IDE_s__funcmem_bld(&__std__pair_unsignedsshort_std__vector_sim__IDE_s__db_funcmem);
void __std__pair_unsignedsshort_std__vector_sim__IDE_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned short,std::vector<sim::IDE> >"), typeid(::std::pair<unsigned short,std::vector<sim::IDE> >), sizeof(::std::pair<unsigned short,std::vector<sim::IDE> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_319, Reflex::Literal("std::pair<unsigned short,std::vector<sim::IDE> >::first_type"))
  .AddTypedef(type_2274, Reflex::Literal("std::pair<unsigned short,std::vector<sim::IDE> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_9219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14046, type_14047), Reflex::Literal("operator="), operator_9220, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14047), Reflex::Literal("pair"), constructor_9221, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_9222, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13954, type_13540), Reflex::Literal("pair"), constructor_9223, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2625, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsshort_std__vector_sim__IDE_s__datamem_bld);
}

//------Delayed data member builder for class pair<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> > > -------------------
void __std__pair_unsignedsshort_std__vector_sim__IDE_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_319, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsshort_std__vector_sim__IDE_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2274, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsshort_std__vector_sim__IDE_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> > > -------------------
void __std__pair_unsignedsshort_std__vector_sim__IDE_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class map<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<sim::IDE, std::allocator<sim::IDE> > > > > -------------------------------
static void destructor_10091(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->::std::map<unsigned short,std::vector<sim::IDE> >::~map)();
}
static void constructor_10092( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >();
  else ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >();
}

static void constructor_10093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >(*(const ::std::less<unsigned short>*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >(*(const ::std::less<unsigned short>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[1]);
  }
}

static void constructor_10094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >(*(const ::std::map<unsigned short,std::vector<sim::IDE> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,std::vector<sim::IDE> >(*(const ::std::map<unsigned short,std::vector<sim::IDE> >*)arg[0]);
}

static  void operator_10095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->operator=)(*(const ::std::map<unsigned short,std::vector<sim::IDE> >*)arg[0]);
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->operator=)(*(const ::std::map<unsigned short,std::vector<sim::IDE> >*)arg[0]);
}

static  void method_10096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->get_allocator)();
}

static  void method_10097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->begin)());
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->begin)();
}

static  void method_10098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->begin)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->begin)();
}

static  void method_10099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->end)());
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->end)();
}

static  void method_10100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->end)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->end)();
}

static  void method_10105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->empty)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->empty)();
}

static  void method_10106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->size)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->size)();
}

static  void method_10107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->max_size)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->max_size)();
}

static  void operator_10108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->operator[])(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->operator[])(*(const unsigned short*)arg[0]);
}

static  void method_10109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_10110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_10111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >,bool>)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->insert)(*(const ::std::pair<const unsigned short,std::vector<sim::IDE> >*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->insert)(*(const ::std::pair<const unsigned short,std::vector<sim::IDE> >*)arg[0]);
}

static  void method_10112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[0],
    *(const ::std::pair<const unsigned short,std::vector<sim::IDE> >*)arg[1]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[0],
    *(const ::std::pair<const unsigned short,std::vector<sim::IDE> >*)arg[1]);
}

static  void method_10113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[0]);
}

static  void method_10114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->erase)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->erase)(*(const unsigned short*)arg[0]);
}

static  void method_10115( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >*)arg[1]);
}

static  void method_10116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->swap)(*(::std::map<unsigned short,std::vector<sim::IDE> >*)arg[0]);
}

static  void method_10117( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->clear)();
}

static  void method_10118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned short>)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->key_comp)();
}

static  void method_10120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_10121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_10122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->count)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->count)(*(const unsigned short*)arg[0]);
}

static  void method_10123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_10124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_10125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_10126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_10127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >,std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > > >)((((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<sim::IDE> >*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static  void method_10128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<sim::IDE> > > >)((((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<sim::IDE> >*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static void method_newdel_2783( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<sim::IDE> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<sim::IDE> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<sim::IDE> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<sim::IDE> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<sim::IDE> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned short,std::vector<sim::IDE> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned short,std::vector<sim::IDE> > >::Generate();
}

//------Dictionary for class map<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<sim::IDE, std::allocator<sim::IDE> > > > > -------------------------------
void __std__map_unsignedsshort_std__vector_sim__IDE_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsshort_std__vector_sim__IDE_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_std__vector_sim__IDE_s__datamem_bld(&__std__map_unsignedsshort_std__vector_sim__IDE_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_std__vector_sim__IDE_s__funcmem_bld(&__std__map_unsignedsshort_std__vector_sim__IDE_s__db_funcmem);
void __std__map_unsignedsshort_std__vector_sim__IDE_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >"), typeid(::std::map<unsigned short,std::vector<sim::IDE> >), sizeof(::std::map<unsigned short,std::vector<sim::IDE> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_319, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::key_type"))
  .AddTypedef(type_2274, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::mapped_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::value_type"))
  .AddTypedef(type_2573, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::key_compare"))
  .AddTypedef(type_2706, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::allocator_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::_Alloc_value_type"))
  .AddTypedef(type_2706, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::_Pair_alloc_type"))
  .AddTypedef(type_2530, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::_Rep_type"))
  .AddTypedef(type_8635, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::pointer"))
  .AddTypedef(type_8637, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::const_pointer"))
  .AddTypedef(type_8639, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::reference"))
  .AddTypedef(type_8641, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::const_reference"))
  .AddTypedef(type_2341, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::iterator"))
  .AddTypedef(type_2666, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::const_iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::size_type"))
  .AddTypedef(type_2459, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::difference_type"))
  .AddTypedef(type_2809, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::reverse_iterator"))
  .AddTypedef(type_2808, Reflex::Literal("std::map<unsigned short,std::vector<sim::IDE> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10091, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10092, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13955, type_13956), Reflex::Literal("map"), constructor_10093, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14186), Reflex::Literal("map"), constructor_10094, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2783, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsshort_std__vector_sim__IDE_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsshort_std__vector_sim__IDE_s__funcmem_bld);
}

//------Delayed data member builder for class map<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<sim::IDE, std::allocator<sim::IDE> > > > > -------------------
void __std__map_unsignedsshort_std__vector_sim__IDE_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2530, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsshort_std__vector_sim__IDE_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<short unsigned int,std::vector<sim::IDE, std::allocator<sim::IDE> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<sim::IDE, std::allocator<sim::IDE> > > > > -------------------
void __std__map_unsignedsshort_std__vector_sim__IDE_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14187, type_14186), Reflex::Literal("operator="), operator_10095, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706), Reflex::Literal("get_allocator"), method_10096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341), Reflex::Literal("begin"), method_10097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("begin"), method_10098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341), Reflex::Literal("end"), method_10099, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("end"), method_10100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_504), Reflex::Literal("empty"), method_10105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("size"), method_10106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("max_size"), method_10107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13541, type_13954), Reflex::Literal("operator[]"), operator_10108, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13541, type_13954), Reflex::Literal("at"), method_10109, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13540, type_13954), Reflex::Literal("at"), method_10110, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2637, type_8641), Reflex::Literal("insert"), method_10111, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341, type_2341, type_8641), Reflex::Literal("insert"), method_10112, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2341), Reflex::Literal("erase"), method_10113, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_13954), Reflex::Literal("erase"), method_10114, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_2341, type_2341), Reflex::Literal("erase"), method_10115, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576, type_14187), Reflex::Literal("swap"), method_10116, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_576), Reflex::Literal("clear"), method_10117, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2573), Reflex::Literal("key_comp"), method_10118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341, type_13954), Reflex::Literal("find"), method_10120, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_13954), Reflex::Literal("find"), method_10121, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_13954), Reflex::Literal("count"), method_10122, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341, type_13954), Reflex::Literal("lower_bound"), method_10123, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_13954), Reflex::Literal("lower_bound"), method_10124, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341, type_13954), Reflex::Literal("upper_bound"), method_10125, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_13954), Reflex::Literal("upper_bound"), method_10126, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_13954), Reflex::Literal("equal_range"), method_10127, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2634, type_13954), Reflex::Literal("equal_range"), method_10128, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<sim::BeamGateInfo, std::allocator<sim::BeamGateInfo> > > -------------------------------
static  void operator_12553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::art::Wrapper<std::vector<sim::BeamGateInfo> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::BeamGateInfo> >*)arg[0]);
  else   (((::art::Wrapper<std::vector<sim::BeamGateInfo> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::BeamGateInfo> >*)arg[0]);
}

static void constructor_12554( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::BeamGateInfo> >(*(const ::art::Wrapper<std::vector<sim::BeamGateInfo> >*)arg[0]);
  else ::new(mem) ::art::Wrapper<std::vector<sim::BeamGateInfo> >(*(const ::art::Wrapper<std::vector<sim::BeamGateInfo> >*)arg[0]);
}

static void constructor_12555( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::BeamGateInfo> >();
  else ::new(mem) ::art::Wrapper<std::vector<sim::BeamGateInfo> >();
}

static void destructor_12556(void*, void * o, const std::vector<void*>&, void *) {
(((::art::Wrapper<std::vector<sim::BeamGateInfo> >*)o)->::art::Wrapper<std::vector<sim::BeamGateInfo> >::~Wrapper)();
}
static  void method_12557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::art::Wrapper<std::vector<sim::BeamGateInfo> >*)o)->Class_Version)());
  else   (((::art::Wrapper<std::vector<sim::BeamGateInfo> >*)o)->Class_Version)();
}

static void method_newdel_5311( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::BeamGateInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::BeamGateInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::BeamGateInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::BeamGateInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::BeamGateInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("art::EDProduct")), ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::BeamGateInfo> >,::art::EDProduct >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Wrapper<std::vector<sim::BeamGateInfo, std::allocator<sim::BeamGateInfo> > > -------------------------------
void __art__Wrapper_std__vector_sim__BeamGateInfo_s__db_datamem(Reflex::Class*);
void __art__Wrapper_std__vector_sim__BeamGateInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__BeamGateInfo_s__datamem_bld(&__art__Wrapper_std__vector_sim__BeamGateInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__BeamGateInfo_s__funcmem_bld(&__art__Wrapper_std__vector_sim__BeamGateInfo_s__db_funcmem);
void __art__Wrapper_std__vector_sim__BeamGateInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::BeamGateInfo> >"), typeid(::art::Wrapper<std::vector<sim::BeamGateInfo> >), sizeof(::art::Wrapper<std::vector<sim::BeamGateInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::art::Wrapper<std::vector<sim::BeamGateInfo> >::Class_Version())
  .AddBase(type_5347, ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::BeamGateInfo> >, ::art::EDProduct >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14664, type_14665), Reflex::Literal("operator="), operator_12553, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14665), Reflex::Literal("Wrapper"), constructor_12554, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12555, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12556, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5311, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__art__Wrapper_std__vector_sim__BeamGateInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__art__Wrapper_std__vector_sim__BeamGateInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<sim::BeamGateInfo, std::allocator<sim::BeamGateInfo> > > -------------------
void __art__Wrapper_std__vector_sim__BeamGateInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_504, Reflex::Literal("present"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__BeamGateInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2266, Reflex::Literal("obj"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__BeamGateInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<sim::BeamGateInfo, std::allocator<sim::BeamGateInfo> > > -------------------
void __art__Wrapper_std__vector_sim__BeamGateInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("Class_Version"), method_12557, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<int, std::allocator<int> > > -------------------------------
static  void operator_12564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::art::Wrapper<std::vector<int> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<int> >*)arg[0]);
  else   (((::art::Wrapper<std::vector<int> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<int> >*)arg[0]);
}

static void constructor_12565( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<int> >(*(const ::art::Wrapper<std::vector<int> >*)arg[0]);
  else ::new(mem) ::art::Wrapper<std::vector<int> >(*(const ::art::Wrapper<std::vector<int> >*)arg[0]);
}

static void constructor_12566( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<int> >();
  else ::new(mem) ::art::Wrapper<std::vector<int> >();
}

static void destructor_12567(void*, void * o, const std::vector<void*>&, void *) {
(((::art::Wrapper<std::vector<int> >*)o)->::art::Wrapper<std::vector<int> >::~Wrapper)();
}
static  void method_12568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::art::Wrapper<std::vector<int> >*)o)->Class_Version)());
  else   (((::art::Wrapper<std::vector<int> >*)o)->Class_Version)();
}

static void method_newdel_5312( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("art::EDProduct")), ::Reflex::BaseOffset< ::art::Wrapper<std::vector<int> >,::art::EDProduct >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Wrapper<std::vector<int, std::allocator<int> > > -------------------------------
void __art__Wrapper_std__vector_int_s__db_datamem(Reflex::Class*);
void __art__Wrapper_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_int_s__datamem_bld(&__art__Wrapper_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_int_s__funcmem_bld(&__art__Wrapper_std__vector_int_s__db_funcmem);
void __art__Wrapper_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("art::Wrapper<std::vector<int> >"), typeid(::art::Wrapper<std::vector<int> >), sizeof(::art::Wrapper<std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::art::Wrapper<std::vector<int> >::Class_Version())
  .AddBase(type_5347, ::Reflex::BaseOffset< ::art::Wrapper<std::vector<int> >, ::art::EDProduct >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14669, type_14670), Reflex::Literal("operator="), operator_12564, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14670), Reflex::Literal("Wrapper"), constructor_12565, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12566, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12567, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5312, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__art__Wrapper_std__vector_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__art__Wrapper_std__vector_int_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<int, std::allocator<int> > > -------------------
void __art__Wrapper_std__vector_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_504, Reflex::Literal("present"), OffsetOf(__shadow__::__art__Wrapper_std__vector_int_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2269, Reflex::Literal("obj"), OffsetOf(__shadow__::__art__Wrapper_std__vector_int_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<int, std::allocator<int> > > -------------------
void __art__Wrapper_std__vector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("Class_Version"), method_12568, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<sim::LBNE10ktPhotons, std::allocator<sim::LBNE10ktPhotons> > > -------------------------------
static  void operator_12575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)arg[0]);
  else   (((::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)arg[0]);
}

static void constructor_12576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >(*(const ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)arg[0]);
  else ::new(mem) ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >(*(const ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)arg[0]);
}

static void constructor_12577( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >();
  else ::new(mem) ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >();
}

static void destructor_12578(void*, void * o, const std::vector<void*>&, void *) {
(((::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)o)->::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >::~Wrapper)();
}
static  void method_12579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)o)->Class_Version)());
  else   (((::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >*)o)->Class_Version)();
}

static void method_newdel_5313( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("art::EDProduct")), ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >,::art::EDProduct >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Wrapper<std::vector<sim::LBNE10ktPhotons, std::allocator<sim::LBNE10ktPhotons> > > -------------------------------
void __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__db_datamem(Reflex::Class*);
void __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__datamem_bld(&__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__db_datamem);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__funcmem_bld(&__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__db_funcmem);
void __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::LBNE10ktPhotons> >"), typeid(::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >), sizeof(::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >::Class_Version())
  .AddBase(type_5347, ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::LBNE10ktPhotons> >, ::art::EDProduct >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14671, type_14672), Reflex::Literal("operator="), operator_12575, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14672), Reflex::Literal("Wrapper"), constructor_12576, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12577, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12578, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5313, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<sim::LBNE10ktPhotons, std::allocator<sim::LBNE10ktPhotons> > > -------------------
void __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_504, Reflex::Literal("present"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2270, Reflex::Literal("obj"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__LBNE10ktPhotons_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<sim::LBNE10ktPhotons, std::allocator<sim::LBNE10ktPhotons> > > -------------------
void __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("Class_Version"), method_12579, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<sim::SimPhotons, std::allocator<sim::SimPhotons> > > -------------------------------
static  void operator_12597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::art::Wrapper<std::vector<sim::SimPhotons> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::SimPhotons> >*)arg[0]);
  else   (((::art::Wrapper<std::vector<sim::SimPhotons> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::SimPhotons> >*)arg[0]);
}

static void constructor_12598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::SimPhotons> >(*(const ::art::Wrapper<std::vector<sim::SimPhotons> >*)arg[0]);
  else ::new(mem) ::art::Wrapper<std::vector<sim::SimPhotons> >(*(const ::art::Wrapper<std::vector<sim::SimPhotons> >*)arg[0]);
}

static void constructor_12599( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::SimPhotons> >();
  else ::new(mem) ::art::Wrapper<std::vector<sim::SimPhotons> >();
}

static void destructor_12600(void*, void * o, const std::vector<void*>&, void *) {
(((::art::Wrapper<std::vector<sim::SimPhotons> >*)o)->::art::Wrapper<std::vector<sim::SimPhotons> >::~Wrapper)();
}
static  void method_12601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::art::Wrapper<std::vector<sim::SimPhotons> >*)o)->Class_Version)());
  else   (((::art::Wrapper<std::vector<sim::SimPhotons> >*)o)->Class_Version)();
}

static void method_newdel_5315( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimPhotons> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimPhotons> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimPhotons> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimPhotons> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimPhotons> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("art::EDProduct")), ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::SimPhotons> >,::art::EDProduct >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Wrapper<std::vector<sim::SimPhotons, std::allocator<sim::SimPhotons> > > -------------------------------
void __art__Wrapper_std__vector_sim__SimPhotons_s__db_datamem(Reflex::Class*);
void __art__Wrapper_std__vector_sim__SimPhotons_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__SimPhotons_s__datamem_bld(&__art__Wrapper_std__vector_sim__SimPhotons_s__db_datamem);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__SimPhotons_s__funcmem_bld(&__art__Wrapper_std__vector_sim__SimPhotons_s__db_funcmem);
void __art__Wrapper_std__vector_sim__SimPhotons_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::SimPhotons> >"), typeid(::art::Wrapper<std::vector<sim::SimPhotons> >), sizeof(::art::Wrapper<std::vector<sim::SimPhotons> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::art::Wrapper<std::vector<sim::SimPhotons> >::Class_Version())
  .AddBase(type_5347, ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::SimPhotons> >, ::art::EDProduct >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14675, type_14676), Reflex::Literal("operator="), operator_12597, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14676), Reflex::Literal("Wrapper"), constructor_12598, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12599, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5315, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__art__Wrapper_std__vector_sim__SimPhotons_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__art__Wrapper_std__vector_sim__SimPhotons_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<sim::SimPhotons, std::allocator<sim::SimPhotons> > > -------------------
void __art__Wrapper_std__vector_sim__SimPhotons_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_504, Reflex::Literal("present"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__SimPhotons_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2272, Reflex::Literal("obj"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__SimPhotons_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<sim::SimPhotons, std::allocator<sim::SimPhotons> > > -------------------
void __art__Wrapper_std__vector_sim__SimPhotons_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("Class_Version"), method_12601, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<sim::SimChannel, std::allocator<sim::SimChannel> > > -------------------------------
static  void operator_12608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::art::Wrapper<std::vector<sim::SimChannel> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::SimChannel> >*)arg[0]);
  else   (((::art::Wrapper<std::vector<sim::SimChannel> >*)o)->operator=)(*(const ::art::Wrapper<std::vector<sim::SimChannel> >*)arg[0]);
}

static void constructor_12609( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::SimChannel> >(*(const ::art::Wrapper<std::vector<sim::SimChannel> >*)arg[0]);
  else ::new(mem) ::art::Wrapper<std::vector<sim::SimChannel> >(*(const ::art::Wrapper<std::vector<sim::SimChannel> >*)arg[0]);
}

static void constructor_12610( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::art::Wrapper<std::vector<sim::SimChannel> >();
  else ::new(mem) ::art::Wrapper<std::vector<sim::SimChannel> >();
}

static void destructor_12611(void*, void * o, const std::vector<void*>&, void *) {
(((::art::Wrapper<std::vector<sim::SimChannel> >*)o)->::art::Wrapper<std::vector<sim::SimChannel> >::~Wrapper)();
}
static  void method_12612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::art::Wrapper<std::vector<sim::SimChannel> >*)o)->Class_Version)());
  else   (((::art::Wrapper<std::vector<sim::SimChannel> >*)o)->Class_Version)();
}

static void method_newdel_5316( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimChannel> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimChannel> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimChannel> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimChannel> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::art::Wrapper<std::vector<sim::SimChannel> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("art::EDProduct")), ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::SimChannel> >,::art::EDProduct >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Wrapper<std::vector<sim::SimChannel, std::allocator<sim::SimChannel> > > -------------------------------
void __art__Wrapper_std__vector_sim__SimChannel_s__db_datamem(Reflex::Class*);
void __art__Wrapper_std__vector_sim__SimChannel_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__SimChannel_s__datamem_bld(&__art__Wrapper_std__vector_sim__SimChannel_s__db_datamem);
Reflex::GenreflexMemberBuilder __art__Wrapper_std__vector_sim__SimChannel_s__funcmem_bld(&__art__Wrapper_std__vector_sim__SimChannel_s__db_funcmem);
void __art__Wrapper_std__vector_sim__SimChannel_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("art::Wrapper<std::vector<sim::SimChannel> >"), typeid(::art::Wrapper<std::vector<sim::SimChannel> >), sizeof(::art::Wrapper<std::vector<sim::SimChannel> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::art::Wrapper<std::vector<sim::SimChannel> >::Class_Version())
  .AddBase(type_5347, ::Reflex::BaseOffset< ::art::Wrapper<std::vector<sim::SimChannel> >, ::art::EDProduct >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14677, type_14678), Reflex::Literal("operator="), operator_12608, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14678), Reflex::Literal("Wrapper"), constructor_12609, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12610, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12611, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5316, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__art__Wrapper_std__vector_sim__SimChannel_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__art__Wrapper_std__vector_sim__SimChannel_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<sim::SimChannel, std::allocator<sim::SimChannel> > > -------------------
void __art__Wrapper_std__vector_sim__SimChannel_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_504, Reflex::Literal("present"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__SimChannel_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2273, Reflex::Literal("obj"), OffsetOf(__shadow__::__art__Wrapper_std__vector_sim__SimChannel_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<sim::SimChannel, std::allocator<sim::SimChannel> > > -------------------
void __art__Wrapper_std__vector_sim__SimChannel_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29), Reflex::Literal("Class_Version"), method_12612, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __sim__BeamGateInfo_dict(); 
      __std__vector_sim__BeamGateInfo__dict(); 
      __std__vector_int__dict(); 
      __sim__LBNE10ktPhotons_dict(); 
      __std__vector_sim__LBNE10ktPhotons__dict(); 
      __sim__OnePhoton_dict(); 
      __std__vector_sim__OnePhoton__dict(); 
      __sim__SimPhotons_dict(); 
      __std__vector_sim__SimPhotons__dict(); 
      __sim__SimChannel_dict(); 
      __std__vector_sim__SimChannel__dict(); 
      __sim__IDE_dict(); 
      __std__vector_sim__IDE__dict(); 
      __std__pair_unsignedsshort_std__vector_sim__IDE_s__dict(); 
      __std__map_unsignedsshort_std__vector_sim__IDE_s__dict(); 
      __art__Wrapper_std__vector_sim__BeamGateInfo_s__dict(); 
      __art__Wrapper_std__vector_int_s__dict(); 
      __art__Wrapper_std__vector_sim__LBNE10ktPhotons_s__dict(); 
      __art__Wrapper_std__vector_sim__SimPhotons_s__dict(); 
      __art__Wrapper_std__vector_sim__SimChannel_s__dict(); 
    }
    ~Dictionaries() {
      type_3553.Unload(); // class sim::BeamGateInfo 
      type_2266.Unload(); // class std::vector<sim::BeamGateInfo> 
      type_2269.Unload(); // class std::vector<int> 
      type_3552.Unload(); // class sim::LBNE10ktPhotons 
      type_2270.Unload(); // class std::vector<sim::LBNE10ktPhotons> 
      type_3549.Unload(); // class sim::OnePhoton 
      type_2271.Unload(); // class std::vector<sim::OnePhoton> 
      type_3548.Unload(); // class sim::SimPhotons 
      type_2272.Unload(); // class std::vector<sim::SimPhotons> 
      type_3554.Unload(); // class sim::SimChannel 
      type_2273.Unload(); // class std::vector<sim::SimChannel> 
      type_3551.Unload(); // class sim::IDE 
      type_2274.Unload(); // class std::vector<sim::IDE> 
      type_2625.Unload(); // class std::pair<unsigned short,std::vector<sim::IDE> > 
      type_2783.Unload(); // class std::map<unsigned short,std::vector<sim::IDE> > 
      type_5311.Unload(); // class art::Wrapper<std::vector<sim::BeamGateInfo> > 
      type_5312.Unload(); // class art::Wrapper<std::vector<int> > 
      type_5313.Unload(); // class art::Wrapper<std::vector<sim::LBNE10ktPhotons> > 
      type_5315.Unload(); // class art::Wrapper<std::vector<sim::SimPhotons> > 
      type_5316.Unload(); // class art::Wrapper<std::vector<sim::SimChannel> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
